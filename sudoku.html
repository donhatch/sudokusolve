<!--
TODO: make it so size doesn't jump, and do the <big> thing
TODO: get mouse-up right (need to listen on window I think)
TODO: show the red/green on hover?  (then maybe don't need down/up)
TODO: get prefill from url param
TODO: make easy way to get prefills from the projecteuler file
TODO: show how many button presses of each type will succeed?

TODONE: disable buttons when they would do nothing

-->
<html>
 <head>
  <style>
   table.toplevel_table {
    border:5px solid black;
    border-collapse:collapse;
    border-spacing:0px;
   }
   tr.after_divider {
     border-top:3px solid gray;
   }
   td.cell.after_divider {
     border-left:3px solid gray;
   }
   td.cell.prefilled {
    background:#e6e6e6;  /* nytimes is #e6e6e6 */
   }
   td.cell { 
    border:1px solid gray; 
    padding:0px; 
    margin:0px; 
    /* 55 seems to be what is used by nytimes, maybe */
    width:75px;
    height:75px;
    text-align:center;
    font-size:200%;  /* XXX hack for now, should get something more principled */
    font-weight:bold;
   }
   td.pencil {
    text-align:center;
    font-size:100%;  /* XXX hack for now, should get something more principled */
    /* XXX this is very unprincipled; sizes don't add up, and it works for only n=3 */
    width:20px;
    height:20px;
    color:black;
   }
  </style>
 </head>
 <body>
  <table>
    <tr>
      <td>
       <table class='toplevel_table'>
        <!-- to be filled in by javascript -->
       </table>
      <td>
       <table>
        <tr>
         <td><input class="propagatesingles" type="button" value="Naked singles" onmouseover="propagateSinglesButtonMouseOver()" onmouseout="propagateSinglesButtonMouseOut()" onmousedown="propagateSinglesButtonMouseDown()" onmouseup="propagateSinglesButtonMouseUp()">
         <small><small><span class="propagatesinglescount"></span></small></small>
        <tr>
         <td><input class="hiddensingles" type="button" value="Hidden singles" onmouseover="hiddenSinglesButtonMouseOver()" onmouseout="hiddenSinglesButtonMouseOut()" onmousedown="hiddenSinglesButtonMouseDown()" onmouseup="hiddenSinglesButtonMouseUp()">
         <small><small><span class="dohiddensinglescount"></span></small></small>
        <tr>
         <td><input class="nakedpairs" type="button" value="Naked pairs" onmouseover="nakedPairsButtonMouseOver()" onmouseout="nakedPairsButtonMouseOut()" onmousedown="nakedPairsButtonMouseDown()" onmouseup="nakedPairsButtonMouseUp()">
         <small><small><span class="donakedpairscount"></span></small></small>
        <tr>
         <td><input class="hiddenpairs" type="button" value="Hidden pairs" onmouseover="hiddenPairsButtonMouseOver()" onmouseout="hiddenPairsButtonMouseOut()" onmousedown="hiddenPairsButtonMouseDown()" onmouseup="hiddenPairsButtonMouseUp()">
         <small><small><span class="dohiddenpairscount"></span></small></small>
        <tr>
         <td><input class="omission" type="button" value="Omission/intersection/pointing/blocking/claiming" onmouseover="omissionButtonMouseOver()" onmouseout="omissionButtonMouseOut()" onmousedown="omissionButtonMouseDown()" onmouseup="omissionButtonMouseUp()">
         <small><small><span class="doomissionscount"></span></small></small>
        <tr>
         <td><input class="undo" type="button" value="Undo" onmousedown="undoButtonMouseDown()" onmouseup="undoButtonMouseUp()">
         <small><small><span class="undostacksize">0</span></small></small>
        <tr>
         <td><input class="redo" type="button" value="Redo" onmousedown="redoButtonMouseDown()" onmouseup="redoButtonMouseUp()">
         <small><small><span class="redostacksize">0</span></small></small>
       </table>
   <table>


 </body>
 <script src="projecteuler_p096_sudoku.txt.js"></script>
 <script>
   const EQ = (a,b) => {
     if (a === b) return true;
     CHECK(typeof(a) == typeof(b));
     return false;
   };
   const CHECK = cond => {
     if (!cond) {
       console.log("CHECK FAILED!");
       document.body.innerHTML = "<big><big>CHECK FAILED!</big></big>";
       throw new Error("CHECK FAILED!");
     }
   };
   const CHECK_EQ = (a,b) => {
     if (!(a === b)) {
       // CBB: dup code except for "EQ" vs etc
       console.log("CHECK_EQ FAILED! a="+Stringify(a)+" b="+Stringify(b));
       document.body.innerHTML = "<big><big>CHECK_EQ FAILED!</big></big>";
       throw new Error("CHECK_EQ FAILED! a="+Stringify(a)+" b="+Stringify(b));
     }
   };
   const CHECK_GE = (a,b) => {
     if (!(a >= b)) {
       // CBB: dup code except for "EQ" vs etc
       console.log("CHECK_GE FAILED! a="+Stringify(a)+" b="+Stringify(b));
       document.body.innerHTML = "<big><big>CHECK_GE FAILED!</big></big>";
       throw new Error("CHECK_GE FAILED! a="+Stringify(a)+" b="+Stringify(b));
     }
   };

   const range = (a,b) => {
     const answer = [];
     for (let i = a; i < b; ++i) {
       answer.push(i);
     }
     return answer;
   };
   const ord = c => {
     CHECK_EQ(c.length, 1);
     return c.charCodeAt(0);
   }
   const chr = o => String.fromCharCode(o);
   const name2intvalue = name => {
     CHECK_EQ(name.length, 1);
     if (name === '0') {
       return '';
     }
     if (ord(name) >= ord('0') && ord(name) <= ord('9')) {
       return ord(name) - ord('0');
     }
     if (ord(name) >= ord('a') && ord(name) <= ord('z')) {
       return ord(name) - ord('a') + 10;
     }
     if (ord(name) >= ord('A') && ord(name) <= ord('Z')) {
       return ord(name) - ord('a') + 10;
     }
     CHECK(false);
   };
   const intvalue2name = intvalue =>  {
     return intvalue<=9 ? ''+intvalue : chr(ord('a') + intvalue-10);
   };
   const removeIf = (arr, f) => {
     for (let i = 0; i < arr.length; ++i) {
       if (f(arr[i])) {
         arr.splice(i, 1);
         i--;
       }
     }
   };
   const deepEquals = (a,b) => {
     if (Array.isArray(a) && Array.isArray(b)) {
       if (a.length != b.length) return false;
       for (let i = 0; i < a.length; ++i) {
         if (!deepEquals(a[i], b[i])) return false;
       }
       return true;
     } else if (a instanceof Map && b instanceof Map)  {
       if (a.size != b.size) return false;
       for (const [akey,avalue] of a.entries()) {
         if (!b.has(akey)) return false;
         if (!deepEquals(b.get(akey), avalue)) return false;
       }
       return true;
     } else if (typeof(a) === "string" && typeof(b) === "string") {
       return a === b;
     } else if (typeof(a) === "number" && typeof(b) === "number") {
       return a === b;
     } else {
       CHECK(false);
     }
   };  // deepEquals
   const deepCopy = object => {
     if (Array.isArray(object)) {
       const answer = [];
       for (let i = 0; i < object.length; ++i) {
         answer.push(deepCopy(object[i]));
       }
       return answer;
     } else if (typeof(object) === "string") {
       return object;
     } else if (typeof(object) === "number") {
       return object;
     } else {
       CHECK(false);
     }
   };  // deepCopy
   const Stringify = object => {
     if (Array.isArray(object)) {
       let answer = '[';
       for (let i = 0; i < object.length; ++i) {
         if (i > 0) answer += ', ';
         answer += Stringify(object[i]);
       }
       answer += ']';
       return answer;
     } else if (typeof(object) === "string") {
       return JSON.stringify(object);
     } else if (typeof(object) === "number") {
       return ''+object;
     } else {
       CHECK(false);
     }
   };  // Stringify
   const Top = arr => arr[arr.length-1];

   const IsSubsetOf = (a,b) => {
     // TODO: check that a and b are both sets.  How?
     for (const x of a) {
       if (!b.has(x)) {
         return false;
       }
     }
     return true;
   };


   console.log("in script");
   console.log("  window.location = ",window.location);
   console.log("  window.location.href = ",window.location.href);

   let n = 3;  // standard puzzle: 3x3x3x3

   let prefill = undefined;

   if (true) {
     //const url_param_prefill = '003020600.900305001.001806400.008102900.700000008.006708200.002609500.800203009.005010300';
     //const url_param_prefill = '1000.0200.0030.0004';

     let url_param_prefill = new URL(window.location.href).searchParams.get("prefill");
     console.log("  url_param_prefill = ",url_param_prefill);

     if (url_param_prefill[0] == 'p') {
       // Get it out of file_contents
       const found = url_param_prefill.match(/^.*[^0-9]([0-9]+)$/);
       console.log("  found = ",found);
       const puzzle_number = parseInt(found[1]);
       console.log("  puzzle_number = ",puzzle_number);
       const puzzle_numeral = ''+((puzzle_number-puzzle_number%10)/10)+(puzzle_number%10);

       const what_to_look_for = "Grid "+puzzle_numeral+"\n";
       console.log("  what_to_look_for = ",what_to_look_for);
       const index = file_contents.indexOf(what_to_look_for);
       console.log("  index = ",index);
       CHECK_GE(index, 0);
       url_param_prefill = ''
       for (let i = index + what_to_look_for.length; i < file_contents.length && url_param_prefill.length < 81; ++i) {
         if (file_contents[i] >= '0' && file_contents[i] <= '9') {
           url_param_prefill += file_contents[i];
         }
       }
       console.log("  url_param_prefill = ",url_param_prefill);

       if (true) {
         // Make "prev" and "next" links
         if (puzzle_number > 1) {
           const scratch = new URL(window.location.href);
           scratch.searchParams.set("prefill", "p"+(puzzle_number-1));
           document.body.innerHTML += '<a href="'+scratch.href+'">prev</a>';
         }
         if (puzzle_number < 50) {
           const scratch = new URL(window.location.href);
           scratch.searchParams.set("prefill", "p"+(puzzle_number+1));
           document.body.innerHTML += ' <a href="'+scratch.href+'">next</a>';
         }
       }
     }

     const prefill_digits_only = url_param_prefill.replace(/[^0-9a-zA-Z]/g, '');
     console.log("  prefill_digits_only = ",prefill_digits_only);

     n = Math.round(Math.sqrt(Math.sqrt(prefill_digits_only.length)));
     console.log("  n = ",n);
     CHECK_EQ(prefill_digits_only.length, n*n*n*n);
     prefill = [];
     for (let i = 0; i < n*n*n*n; ++i) {
       prefill.push(name2intvalue(prefill_digits_only[i]));
     }
     console.log("  prefill = ",prefill);
   } else {
     prefill = [];
     for (let i = 0; i < n*n*n*n; ++i) {
       prefill.push(0);
     }
   }



   let the_table = document.getElementsByClassName("toplevel_table");
   console.log("  the_table = ",the_table);
   CHECK_EQ(the_table.length, 1);
   the_table = the_table[0];
   console.log("  the_table = ",the_table);

   let table_inner_html = ''
   for (let i = 0; i < n*n; ++i) {
     const after_divider_maybe = i!=0 && i%n==0 ? " after_divider" : "";
     table_inner_html += '<tr class="toplevel_row'+after_divider_maybe+'">'
     for (let j = 0; j < n*n; ++j) {
       const after_divider_maybe = j!=0 && j%n==0 ? " after_divider" : "";
       const prefilled_maybe = prefill[i*n*n+j] != 0 ? " prefilled" : "";
       table_inner_html += ' <td class="cell'+after_divider_maybe+prefilled_maybe+'">';
     }
   }

   the_table.innerHTML = table_inner_html;

   const cells = document.getElementsByClassName("cell");
   CHECK_EQ(cells.length, n*n*n*n);


   // State will be a list of candidates for each cell.
   let state = [];
   for (let i = 0; i < n*n; ++i) {
     state.push([]);
     for (let j = 0; j < n*n; ++j) {
       if (prefill[i*n*n+j] == 0) {
         state[i].push(range(1,n*n+1));
         //console.log("  range(1,n*n+1) = ",range(1,n*n+1));
       } else {
         state[i].push([prefill[i*n*n+j]]);
       }
     }
   }
   console.log("  initial state = ",state);

   // Propagate singles to eliminate candidates.
   const propagateSingles = (n, state) => {
     console.log("      in propagateSingles(n="+n+", state)");
     const originalState = deepCopy(state);  // TODO: this is silly. make states unmutable instead
     for (let i = 0; i < n*n; ++i) {
       for (let j = 0; j < n*n; ++j) {
         if (originalState[i][j].length == 1) {
           // same row
           //console.log("      state["+i+"]["+j+"] is a singleton "+originalState[i][j][0]+"; lasering");
           for (let k = 0; k < n*n; ++k) {
             if (k != j) {
               removeIf(state[i][k], x => x===originalState[i][j][0]);
             }
           }
           for (let k = 0; k < n*n; ++k) {
             if (k != i) {
               removeIf(state[k][j], x => x===originalState[i][j][0]);
             }
           }
           for (let ii = 0; ii < n; ++ii) {
             for (let jj = 0; jj < n; ++jj) {
               if (ii != i%n || jj != j%n) {
                 removeIf(state[i-i%n+ii][j-j%n+jj], x=>x===originalState[i][j][0]);
               }
             }
           }
         }
       }
     }
     console.log("      out propagateSingles(n="+n+", state)");
   };  // propagateSingles

   const all_houses = [];
   {
     for (let i = 0; i < n*n; ++i) {
       all_houses.push([]);
       for (let j = 0; j < n*n; ++j) Top(all_houses).push([i,j]);
     }
     for (let j = 0; j < n*n; ++j) {
       all_houses.push([]);
       for (let i = 0; i < n*n; ++i) Top(all_houses).push([i,j]);
     }
     for (let ii = 0; ii < n; ++ii) {
       for (let jj = 0; jj < n; ++jj) {
         all_houses.push([]);
         for (let iii = 0; iii < n; ++iii) {
           for (let jjj = 0; jjj < n; ++jjj) {
             Top(all_houses).push([ii*n+iii, jj*n+jjj]);
           }
         }
       }
     }
   }
   const coords2houses = [];
   {
     for (let i = 0; i < n*n; ++i) {
       coords2houses.push([]);
       for (let j = 0; j < n*n; ++j) {
         Top(coords2houses).push([]);
       }
     }
     for (let ihouse = 0; ihouse < all_houses.length; ++ihouse) {
       for (let iinhouse = 0; iinhouse < n*n; ++iinhouse) {
         const coord = all_houses[ihouse][iinhouse];
         coords2houses[coord[0]][coord[1]].push(ihouse);
       }
     }
   }



   const doHiddenSingles = (n, state) => {
     const verbose_level = 1;
     if (verbose_level >= 1) console.log("        in doHiddenSingles(n="+n+", state)");
     const originalState = deepCopy(state);  // TODO: this is silly. make states unmutable instead
     // For each digit and house (i.e. row, column, or block),
     // if there's only one place the digit can go
     // in that house, then put it there
     // (i.e. remove all other candidates in that cell).
     if (verbose_level >= 2) console.log("          all_houses = "+Stringify(all_houses));

     for (let digit = 1; digit <= n*n; ++digit) {
       if (verbose_level >= 2) console.log("              digit = "+digit);
       for (let ihouse = 0; ihouse < all_houses.length; ++ihouse) {
         const candidatePositionsInHouse = [];
         const XXXsuperdebug = digit==4 && ihouse == 19;
         for (let iinhouse = 0; iinhouse < all_houses[ihouse].length; ++iinhouse) {
           const coords = all_houses[ihouse][iinhouse];
           if (originalState[coords[0]][coords[1]].includes(digit)) {
             candidatePositionsInHouse.push(iinhouse);
           }
         }
         if (candidatePositionsInHouse.length === 1) {
           if (verbose_level >= 2) console.log("                  digit "+intvalue2name(digit)+" can go in only position "+candidatePositionsInHouse[0]+":"+all_houses[ihouse][candidatePositionsInHouse[0]]+" in house "+ihouse+" = "+Stringify(all_houses[ihouse]));
           const coords = all_houses[ihouse][candidatePositionsInHouse[0]];
           state[coords[0]][coords[1]].length = 1;
           state[coords[0]][coords[1]][0] = digit;
         }
       }
     }

     if (verbose_level >= 1) console.log("        out doHiddenSingles(n="+n+", state)");
   };  // doHiddenSingles

   const doNakedTuples = (tuplicity, n, state) => {
     const verbose_level = 1;
     if (verbose_level >= 1) console.log("        in doNaketTuples(tuplicity="+tuplicity+", n="+n+", state)");
     const originalState = deepCopy(state);  // TODO: this is silly. make states unmutable instead
     for (let ihouse = 0; ihouse < all_houses.length; ++ihouse) {
       if (verbose_level >= 2) console.log("            ihouse = "+ihouse+" = "+Stringify(all_houses[ihouse]));
       // What exactly is a naked triple?
       // Well, it's 3 different digits
       // whose union spans only 3 different cells in a particular house.

       // CBB: should be array indexed by digit, but the 1-basing makes it awkward
       const digit2indicesInHouse = new Map();
       for (let digit = 1; digit <= n*n; ++digit) {
         digit2indicesInHouse.set(digit, []);
       }
       for (let iinhouse = 0; iinhouse < n*n; ++iinhouse) {
         const coords = all_houses[ihouse][iinhouse];
         for (const digit of originalState[coords[0]][coords[1]]) {
           digit2indicesInHouse.get(digit).push(iinhouse);
         }
       }

       const interesting_digits = [];
       for (let digit = 1; digit <= n*n; ++digit) {
         if (digit2indicesInHouse.get(digit).size >= 1 &&
             digit2indicesInHouse.get(digit).size <= tuplicity) {
           interesting_digits.push(digit);
         }
       }

       if (tuplicity === 3) {
         // TODO: dont hard code. this is just to get an initial implementation
         // working for triples, so I can use it for reference
         for (const digit0 of interesting_digits) {
           for (const digit1 of interesting_digits) {
             if (digit1 <= digit0) continue;
             for (const digit2 of interesting_digits) {
               if (digit2 <= digit1) continue;
               if (verbose_level >= 2) console.log("            ihouse = "+ihouse+" = "+Stringify(all_houses[ihouse]));
             }
           }
         }
       }

     }
     if (verbose_level >= 1) console.log("        out doNaketTuples(tuplicity="+tuplicity+", n="+n+", state)");
   };  // doNakedTuples

   const doNakedPairs = (n, state) => {
     const verbose_level = 1;
     if (verbose_level >= 1) console.log("        in doNakedPairs(n="+n+", state)");
     const originalState = deepCopy(state);  // TODO: this is silly. make states unmutable instead

     for (let ihouse = 0; ihouse < all_houses.length; ++ihouse) {
       if (verbose_level >= 2) console.log("            ihouse = "+ihouse+" = "+Stringify(all_houses[ihouse]));
       const map = new Map();
       for (let iinhouse = 0; iinhouse < all_houses[ihouse].length; ++iinhouse) {
         const coords = all_houses[ihouse][iinhouse];
         const stateCell = originalState[coords[0]][coords[1]];
         if (stateCell.length == 2) {
           const key = ''+stateCell;  // e.g. "4,5"
           if (!map.has(key)) {
             map.set(key, []);
           }
           map.get(key).push(iinhouse);
         }
       }
       for (const [key,value] of map.entries()) {
         if (value.length != 1) {
           if (verbose_level >= 2) console.log("                naked pair! key="+Stringify(key)+" value="+Stringify(value));
           CHECK_EQ(value.length, 2);
           const ii0inhouse = value[0];
           const ii1inhouse = value[1];
           const coords0 = all_houses[ihouse][ii0inhouse];
           const coords1 = all_houses[ihouse][ii1inhouse];
           CHECK(!deepEquals(coords0,coords1));
           const the_pair0 = originalState[coords0[0]][coords0[1]];
           const the_pair1 = originalState[coords0[0]][coords0[1]];
           CHECK(deepEquals(the_pair0, the_pair1));
           if (verbose_level >= 2) console.log("                    the_pair = "+Stringify(the_pair0));

           for (let jinhouse = 0; jinhouse < all_houses[ihouse].length; ++jinhouse) {
             if (jinhouse != ii0inhouse && jinhouse != ii1inhouse) {
               const coords = all_houses[ihouse][jinhouse];
               removeIf(state[coords[0]][coords[1]], x => x===the_pair0[0] || x===the_pair0[1]);
             }
           }
         }
       }
     }

     if (verbose_level >= 1) console.log("        out doNakedPairs(n="+n+", state)");
   };  // doNakedPairs

   const doHiddenPairs = (n, state) => {
     const verbose_level = 1;
     if (verbose_level >= 1) console.log("        in doHiddenPairs(n="+n+", state)");
     const originalState = deepCopy(state);  // TODO: this is silly. make states unmutable instead

     // For each house, look for pairs of digits such that each of
     // them occurs only twice in the house, and in the same place.

     for (let ihouse = 0; ihouse < all_houses.length; ++ihouse) {
       if (verbose_level >= 2) console.log("            ihouse = "+ihouse+" = "+Stringify(all_houses[ihouse]));
       // CBB: should be array indexed by digit, but the 1-basing makes it awkward
       const digit2indicesInHouse = new Map();
       for (let digit = 1; digit <= n*n; ++digit) {
         digit2indicesInHouse.set(digit, []);
       }
       for (let iinhouse = 0; iinhouse < n*n; ++iinhouse) {
         const coords = all_houses[ihouse][iinhouse];
         for (const digit of originalState[coords[0]][coords[1]]) {
           digit2indicesInHouse.get(digit).push(iinhouse);
         }
       }

       const map = new Map();
       for (const [digit,indices] of digit2indicesInHouse.entries()) {
         if (indices.length === 2) {
           const indiceskey = ''+indices;  // e.g. "4,7"
           if (!map.has(indiceskey)) {
             map.set(indiceskey, []);
           }
           map.get(indiceskey).push(digit);
         }
       }
       for (const [indiceskey,digits] of map) {
         if (digits.length != 1) {
           CHECK_EQ(digits.length, 2);
           if (verbose_level >= 2) console.log("          found a (maybe) hidden pair! digits="+Stringify(digits)+" in house "+ihouse+" = "+Stringify(all_houses[ihouse]));
           const indices = digit2indicesInHouse.get(digits[0]);
           CHECK(deepEquals(indices, digit2indicesInHouse.get(digits[1])));
           const coords0 = all_houses[ihouse][indices[0]];
           const coords1 = all_houses[ihouse][indices[1]];
           CHECK(!deepEquals(coords0, coords1));
           removeIf(state[coords0[0]][coords0[1]], x => x!=digits[0] && x!=digits[1]);
           removeIf(state[coords1[0]][coords1[1]], x => x!=digits[0] && x!=digits[1]);
         }
       }
     }

     if (verbose_level >= 1) console.log("        out doHiddenPairs(n="+n+", state)");
   };  // doHiddenPairs

   const doOmissions = (n, state) => {
     const verbose_level = 1;
     if (verbose_level >= 1) console.log("        in doOmissions(n="+n+", state)");
     const originalState = deepCopy(state);  // TODO: this is silly. make states unmutable instead

     // When a given digit's occurrances (candidacies) in house A
     // is limited to an intersecting house B,
     // then that digit can be eliminated from the rest of house B.
     // (one of A or B will be a block, the other will be a row or
     // column)

     for (let digit = 1; digit <= n*n; ++digit) {
       if (verbose_level >= 1) console.log("          digit = "+digit);
       const house2coordKeysContainingDigit = new Map();
       {
         for (let ihouse = 0; ihouse < all_houses.length; ++ihouse) {
           for (let iinhouse = 0; iinhouse < all_houses[ihouse].length; ++iinhouse) {
             const coords = all_houses[ihouse][iinhouse];
             if (originalState[coords[0]][coords[1]].includes(digit)) {
               coordKey = ''+coords;
               if (!house2coordKeysContainingDigit.has(ihouse)) house2coordKeysContainingDigit.set(ihouse, new Set());
               house2coordKeysContainingDigit.get(ihouse).add(coordKey);
             }
           }
         }
       }

       for (const [ihouse0,coordKeys0] of house2coordKeysContainingDigit.entries()) {
         for (const [ihouse1,coordKeys1] of house2coordKeysContainingDigit.entries()) {
           if (ihouse0 == ihouse1) continue;
           if (coordKeys0.size == 1) continue;  // this is already covered under lone single or something

           // Are all occurrances of digit in house0 also in house1?
           if (IsSubsetOf(coordKeys0, coordKeys1)) {
             if (verbose_level >= 1) console.log("              Hey! every occurrance of digit "+digit+" in house "+ihouse0+" is also in "+ihouse1);
             if (verbose_level >= 1) console.log("                  coordKeys0 = "+Array.from(coordKeys0));
             if (verbose_level >= 1) console.log("                  coordKeys1 = "+Array.from(coordKeys1));
             // Remove all other occurrances of digit in house1.
             for (let iinhouse1 = 0; iinhouse1 < all_houses[ihouse1].length; ++iinhouse1) {
               const coords = all_houses[ihouse1][iinhouse1];
               if (originalState[coords[0]][coords[1]].includes(digit) &&
                   !coords2houses[coords[0]][coords[1]].includes(ihouse0)) {
                 if (verbose_level >= 1) console.log("                      so can remove the "+digit+" at "+Stringify(coords));
                 removeIf(state[coords[0]][coords[1]], x => x===digit);
               }
             }
           }
         }
       }
     }

     if (verbose_level >= 1) console.log("        out doOmissions(n="+n+", state)");
   };  // doOmissions


   const undoStack = [];
   const redoStack = [];
   const propagateSinglesButton = document.getElementsByClassName("propagatesingles")[0];
   const hiddenSinglesButton = document.getElementsByClassName("hiddensingles")[0];
   const nakedPairsButton = document.getElementsByClassName("nakedpairs")[0];
   const hiddenPairsButton = document.getElementsByClassName("hiddenpairs")[0];
   const omissionButton = document.getElementsByClassName("omission")[0];
   const undoButton = document.getElementsByClassName("undo")[0];
   const redoButton = document.getElementsByClassName("redo")[0];
   const propagateSinglesCountSpan = document.getElementsByClassName("propagatesinglescount")[0];
   const doHiddenSinglesCountSpan = document.getElementsByClassName("dohiddensinglescount")[0];
   const doNakedPairsCountSpan = document.getElementsByClassName("donakedpairscount")[0];
   const doHiddenPairsCountSpan = document.getElementsByClassName("dohiddenpairscount")[0];
   const doOmissionsCountSpan = document.getElementsByClassName("doomissionscount")[0];
   const undoStackSizeSpan = document.getElementsByClassName("undostacksize")[0];
   const redoStackSizeSpan = document.getElementsByClassName("redostacksize")[0];

   const howManyTimesStateWillChange = (state,changeState) => {
     let answer = 0;
     while (true) {
       const newState = deepCopy(state);
       changeState(newState);
       if (deepEquals(state, newState)) {
         break;
       }
       ++answer;
       state = newState;
     }
     return answer;
   };  // howManyTimesStateWillChange

   // This must be separate from updateUiFromStatePair: we do *not* want
   // to do it on mousedown, since that will prevent recognizing mouseup!
   const updateUndoRedoButtons = () => {
     undoButton.disabled = (undoStack.length === 0);
     redoButton.disabled = (redoStack.length === 0);
     undoStackSizeSpan.innerHTML = ''+undoStack.length;
     redoStackSizeSpan.innerHTML = ''+redoStack.length;
     const nPropagates = howManyTimesStateWillChange(state, scratchState=>propagateSingles(n,scratchState))
     const nDoHiddenSingles = howManyTimesStateWillChange(state, scratchState=>doHiddenSingles(n,scratchState));
     const nDoNakedPairs = howManyTimesStateWillChange(state, scratchState=>doNakedPairs(n,scratchState));
     const nDoHiddenPairs = howManyTimesStateWillChange(state, scratchState=>doHiddenPairs(n,scratchState));
     const nDoOmissions = howManyTimesStateWillChange(state, scratchState=>doOmissions(n,scratchState));

     propagateSinglesButton.disabled = nPropagates===0;
     hiddenSinglesButton.disabled = nDoHiddenSingles===0;
     nakedPairsButton.disabled = nDoNakedPairs===0;
     hiddenPairsButton.disabled = nDoHiddenPairs===0;
     omissionButton.disabled = nDoOmissions===0;

     propagateSinglesCountSpan.innerHTML = ''+nPropagates;
     doHiddenSinglesCountSpan.innerHTML = ''+nDoHiddenSingles;
     doNakedPairsCountSpan.innerHTML = ''+nDoNakedPairs;
     doHiddenPairsCountSpan.innerHTML = ''+nDoHiddenPairs;
     doOmissionsCountSpan.innerHTML = ''+nDoOmissions;
   };

   // Show common stuff in black, appearing stuff in green, disappearing stuff in red
   const updateUiFromStatePair = (state0,state1) => {
     CHECK(Array.isArray(state0));
     CHECK(Array.isArray(state1));
     for (let i = 0; i < n*n; ++i) {
       for (let j = 0; j < n*n; ++j) {
         if (state0[i][j].length === 1 &&
             state1[i][j].length === 1 &&
             state0[i][j][0] == state1[i][j][0]) {
           const intvalue = state0[i][j][0];
           const charvalue = intvalue2name(intvalue);
           cells[i*n*n+j].innerHTML = charvalue;
         } else {
           let cell_inner_html = '';
           cell_inner_html += '<table>'

           for (let subi = 0; subi < n; ++subi) {
             cell_inner_html += '<tr>'
             for (let subj = 0; subj < n; ++subj) {
               cell_inner_html += '<td class="pencil">'
               const intvalue = subi*n+subj+1;
               const includes0 = state0[i][j].includes(intvalue);
               const includes1 = state1[i][j].includes(intvalue);
               if (includes0 || includes1) {
                 const color = !includes0 ? '#00c000' : !includes1 ? 'red' : 'black';
                 const weight = !includes0 || !includes1 ? 'bold' : 'normal';
                 cell_inner_html += '<span style="font-weight:'+weight+'; color:'+color+';">';
                 // TODO: make it so size doesn't jump, and do this <big> thing!
                 //if (!includes0 || !includes1) { cell_inner_html += '<big>'; }
                 cell_inner_html += '' + intvalue2name(intvalue);
                 //if (!includes0 || !includes1) { cell_inner_html += '</big>'; }
                 cell_inner_html += '</span>';
               }
             }
           }
           cell_inner_html += '</table>'
           cells[i*n*n+j].innerHTML = cell_inner_html;
         }
       }
     }
   };  // updateUiFromStatePair

   if (false) {
     // Just exercise it
     undoStack.push(deepCopy(state));
     state = undoStack.pop();
   }
   updateUiFromStatePair(state,state);
   updateUndoRedoButtons();

   const propagateSinglesButtonMouseOver = () => {
     console.log("    in propagateSinglesButtonMouseOver");
     const scratchState = deepCopy(state);
     propagateSingles(n, scratchState);
     updateUiFromStatePair(state,scratchState);
     console.log("    out propagateSinglesButtonMouseOver");
   };
   const propagateSinglesButtonMouseOut = () => {
     console.log("    in propagateSinglesButtonMouseOut");
     updateUiFromStatePair(state,state);
     console.log("    out propagateSinglesButtonMouseOut");
   };
   const propagateSinglesButtonMouseDown = () => {
     console.log("    in propagateSinglesButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     redoStack.length = 0;  // clear
     undoStack.push(deepCopy(state));
     propagateSingles(n, state);
     updateUiFromStatePair(Top(undoStack),state);
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out propagateSinglesButtonMouseDown");
   };
   const propagateSinglesButtonMouseUp = () => {
     console.log("    in propagateSinglesButtonMouseUp");
     updateUiFromStatePair(state,state);
     updateUndoRedoButtons();
     console.log("    out propagateSinglesButtonMouseUp");
   };

   const hiddenSinglesButtonMouseOver = () => {
     console.log("    in propagateSinglesButtonMouseOver");
     const scratchState = deepCopy(state);
     doHiddenSingles(n, scratchState);
     updateUiFromStatePair(state,scratchState);
     console.log("    out propagateSinglesButtonMouseOver");
   };
   const hiddenSinglesButtonMouseOut = () => {
     console.log("    in propagateSinglesButtonMouseOut");
     updateUiFromStatePair(state,state);
     console.log("    out propagateSinglesButtonMouseOut");
   };
   const hiddenSinglesButtonMouseDown = () => {
     console.log("    in hiddenSinglesButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     redoStack.length = 0;  // clear
     undoStack.push(deepCopy(state));
     doHiddenSingles(n, state);
     updateUiFromStatePair(Top(undoStack),state);
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out hiddenSinglesButtonMouseDown");
   };
   const hiddenSinglesButtonMouseUp = () => {
     console.log("    in hiddenSinglesButtonMouseUp");
     updateUiFromStatePair(state,state);
     updateUndoRedoButtons();
     console.log("    out hiddenSinglesButtonMouseUp");
   };

   const nakedPairsButtonMouseOver = () => {
     console.log("    in propagateSinglesButtonMouseOver");
     const scratchState = deepCopy(state);
     doNakedPairs(n, scratchState);
     updateUiFromStatePair(state,scratchState);
     console.log("    out propagateSinglesButtonMouseOver");
   };
   const nakedPairsButtonMouseOut = () => {
     console.log("    in propagateSinglesButtonMouseOut");
     updateUiFromStatePair(state,state);
     console.log("    out propagateSinglesButtonMouseOut");
   };
   const nakedPairsButtonMouseDown = () => {
     console.log("    in nakedPairsButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     redoStack.length = 0;  // clear
     undoStack.push(deepCopy(state));
     doNakedPairs(n, state);
     updateUiFromStatePair(Top(undoStack),state);
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out nakedPairsButtonMouseDown");
   };
   const nakedPairsButtonMouseUp = () => {
     console.log("    in nakedPairsButtonMouseUp");
     updateUiFromStatePair(state,state);
     updateUndoRedoButtons();
     console.log("    out nakedPairsButtonMouseUp");
   };

   const hiddenPairsButtonMouseOver = () => {
     console.log("    in propagateSinglesButtonMouseOver");
     const scratchState = deepCopy(state);
     doHiddenPairs(n, scratchState);
     updateUiFromStatePair(state,scratchState);
     console.log("    out propagateSinglesButtonMouseOver");
   };
   const hiddenPairsButtonMouseOut = () => {
     console.log("    in propagateSinglesButtonMouseOut");
     updateUiFromStatePair(state,state);
     console.log("    out propagateSinglesButtonMouseOut");
   };
   const hiddenPairsButtonMouseDown = () => {
     console.log("    in hiddenPairsButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     redoStack.length = 0;  // clear
     undoStack.push(deepCopy(state));
     doHiddenPairs(n, state);
     updateUiFromStatePair(Top(undoStack),state);
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out hiddenPairsButtonMouseDown");
   };
   const hiddenPairsButtonMouseUp = () => {
     console.log("    in hiddenPairsButtonMouseUp");
     updateUiFromStatePair(state,state);
     updateUndoRedoButtons();
     console.log("    out hiddenPairsButtonMouseUp");
   };

   const omissionButtonMouseOver = () => {
     console.log("    in propagateSinglesButtonMouseOver");
     const scratchState = deepCopy(state);
     doOmissions(n, scratchState);
     updateUiFromStatePair(state,scratchState);
     console.log("    out propagateSinglesButtonMouseOver");
   };
   const omissionButtonMouseOut = () => {
     console.log("    in propagateSinglesButtonMouseOut");
     updateUiFromStatePair(state,state);
     console.log("    out propagateSinglesButtonMouseOut");
   };
   const omissionButtonMouseDown = () => {
     console.log("    in omissionButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     redoStack.length = 0;  // clear
     undoStack.push(deepCopy(state));
     doOmissions(n, state);
     updateUiFromStatePair(Top(undoStack),state);
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out omissionButtonMouseDown");
   };
   const omissionButtonMouseUp = () => {
     console.log("    in omissionButtonMouseUp");
     updateUiFromStatePair(state,state);
     updateUndoRedoButtons();
     console.log("    out omissionButtonMouseUp");
   };

   const undoButtonMouseDown = () => {
     console.log("    in undoButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     if (undoStack.length >= 1) {
       redoStack.push(state);
       state = undoStack.pop();
       // It seems to be less confusing if we show
       // undos in the same color as the do's/redo's,
       // even though they are doing the opposite thing.
       updateUiFromStatePair(state, Top(redoStack));
     } else {
       // This shouldn't ever happen because the button should be disabled
       // when there's nothing to undo.
       console.log("      nothing to undo!");
     }
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out undoButtonMouseDown");
   };
   const undoButtonMouseUp = () => {
     console.log("    in undoButtonMouseUp");
     updateUiFromStatePair(state,state);
     updateUndoRedoButtons();
     console.log("    out undoButtonMouseUp");
   };
   const redoButtonMouseDown = () => {
     console.log("    in redoButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     if (redoStack.length >= 1) {
       undoStack.push(state);
       state = redoStack.pop();
       updateUiFromStatePair(Top(undoStack), state);
     } else {
       // This shouldn't ever happen because the button should be disabled
       // when there's nothing to redo.
       console.log("      nothing to redo!");
     }
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out redoButtonMouseDown");
   };
   const redoButtonMouseUp = () => {
     console.log("    in redoButtonMouseUp");
     updateUiFromStatePair(state,state);
     updateUndoRedoButtons();
     console.log("    out redoButtonMouseUp");
   };

   //console.log("  file_contents = ",file_contents);
   console.log("out script");
 </script>
</html>
