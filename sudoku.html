<!--

TODO: better way to input nytimes puzzle----  it's too long and the input text thing chokes!  (maybe it's because editing history?)

TODO: distinguish between naked single pencilled, and penned.
TODO: think about whether it makes sense to auto-update candidates
      (i.e. the naked single thing).
      hover: show result of move
      down: do move, show result of updating candidates
      up: update the candidates
      That might work nicely!
      Idea: when down, i.e. move done and showing result of updating candidates, maybe use 2 different colors for about-to-remove and remove? hmm.

TODO: layout flashing at beginning because no table.  can I fix that??
TODO: refactor to make the states immutable
TODO: make it so size doesn't jump, and do the <big> thing
TODO: get mouse-up right (need to listen on window I think)
TODO: show the red/green on hover?  (then maybe don't need down/up)
TODO: show how many button presses of each type will succeed?
TODO: don't do hidden quads that are uninteresting due to pending naked singles, since it looks dorky to have that button enabled at start

TODO: get prefill from url param  (hmm, maybe not useful? not sure)

TODONE: make easy way to get prefills from the projecteuler file (hard coded)
TODONE: disable buttons when they would do nothing

TODO: research more advanced strategies?
      e.g. referred to on https://krazydad.com/hexsudoku/ :
      X-Wing, XY-Wing, Swordfish



TODO: find a way to input puzzles from sites such as https://1sudoku.com/sudoku-variants/super-sudoku-16x16

-->
<html>
 <head>
  <style>
   table.toplevel_table {
    border:5px solid black;
    border-collapse:collapse;
    border-spacing:0px;
   }
   tr.after_divider {
     border-top:3px solid gray;
   }
   td.cell.after_divider {
     border-left:3px solid gray;
   }
   td.cell.prefilled {
    background:#e6e6e6;  /* nytimes is #e6e6e6 */
   }
   td.cell { 
    border:1px solid gray; 
    padding:0px; 
    margin:0px; 
    /* 55 seems to be what is used by nytimes, maybe */
    width:75px;
    height:75px;
    text-align:center;
    font-size:200%;  /* XXX hack for now, should get something more principled */
    font-weight:bold;
   }
   td.pencil {
    text-align:center;
    font-size:100%;  /* XXX hack for now, should get something more principled */
    /* XXX this is very unprincipled; sizes don't add up, and it works for only n=3 */
    width:20px;
    height:20px;
    color:black;
   }
  </style>
 </head>
 <body>
  <table>
    <tr>
      <td>
       <table class='toplevel_table'>
        <!-- to be filled in by javascript -->
       </table>

      <td>
       <table>

        <tr>
         <td><input class="propagatesingles" type="button" value="Naked singles" onmouseover="propagateSinglesButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="propagateSinglesButtonMouseDown()" onmouseup="anyButtonMouseUp()">
         <small><small><span class="propagatesinglescount"></span></small></small>

        <tr>
         <td><input class="hiddensingles" type="button" value="Hidden singles" onmouseover="hiddenSinglesButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="hiddenSinglesButtonMouseDown()" onmouseup="anyButtonMouseUp()">
         <small><small><span class="dohiddensinglescount"></span></small></small>

        <tr>
         <td><input class="nakedpairs" type="button" value="Naked pairs" onmouseover="nakedPairsButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="nakedPairsButtonMouseDown()" onmouseup="anyButtonMouseUp()">
         <small><small><span class="donakedpairscount"></span></small></small>

        <tr>
         <td><input class="hiddenpairs" type="button" value="Hidden pairs" onmouseover="hiddenPairsButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="hiddenPairsButtonMouseDown()" onmouseup="anyButtonMouseUp()">
         <small><small><span class="dohiddenpairscount"></span></small></small>

        <tr>
         <td><input class="nakedtriples" type="button" value="Naked triples" onmouseover="nakedTriplesButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="nakedTriplesButtonMouseDown()" onmouseup="anyButtonMouseUp()">
         <small><small><span class="donakedtriplescount"></span></small></small>

        <tr>
         <td><input class="hiddentriples" type="button" value="Hidden triples" onmouseover="hiddenTriplesButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="hiddenTriplesButtonMouseDown()" onmouseup="anyButtonMouseUp()">
         <small><small><span class="dohiddentriplescount"></span></small></small>

        <tr>
         <td><input class="nakedquads" type="button" value="Naked quads" onmouseover="nakedQuadsButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="nakedQuadsButtonMouseDown()" onmouseup="anyButtonMouseUp()">
         <small><small><span class="donakedquadscount"></span></small></small>

        <tr>
         <td><input class="hiddenquads" type="button" value="Hidden quads" onmouseover="hiddenQuadsButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="hiddenQuadsButtonMouseDown()" onmouseup="anyButtonMouseUp()">
         <small><small><span class="dohiddenquadscount"></span></small></small>

        <tr>
         <td><input class="omission" type="button" value="Omission/intersection/pointing/blocking/claiming" onmouseover="omissionButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="omissionButtonMouseDown()" onmouseup="anyButtonMouseUp()">
         <small><small><span class="doomissionscount"></span></small></small>

        <tr>
         <td><input class="undo" type="button" value="Undo" onmousedown="undoButtonMouseDown()" onmouseup="anyButtonMouseUp()">
         <small><small><span class="undostacksize">0</span></small></small>

        <tr>
         <td><input class="redo" type="button" value="Redo" onmousedown="redoButtonMouseDown()" onmouseup="anyButtonMouseUp()">
         <small><small><span class="redostacksize">0</span></small></small>

        <!-- XXX HACK to get the buttons higher.  TODO: top-justify them -->
        <tr>
         <td><hr>

        <tr>
         <td>
           <input class="redo" type="button" value="Reset to pasted from crackingthecryptic.com or 1sudoko.com:" onclick="resetButtonClicked()">
           <input id="prefill" onkeydown="inputKeyDown(event)"></input>

        <tr>
         <td>
         <br><br><br><br><br><br><br><br><br>
         <br><br><br><br><br><br><br><br><br>

       </table>
   <table>


 </body>
 <script src="projecteuler_p096_sudoku.txt.js"></script>
 <script>
   "use strict";
   const EQ = (a,b) => {
     if (a === b) return true;
     CHECK(typeof(a) == typeof(b));
     return false;
   };
   const CHECK = cond => {
     if (!cond) {
       console.log("CHECK FAILED!");
       document.body.innerHTML = "<big><big>CHECK FAILED!</big></big>";
       throw new Error("CHECK FAILED!");
     }
   };
   const CHECK_EQ = (a,b) => {
     if (!(a === b)) {
       // CBB: dup code except for "EQ" vs etc
       // CBB: sometimes it would be better to use `,` instead of `+` to take advantage of console's stringification.  but sometimes not.
       console.log("CHECK_EQ FAILED! a="+Stringify(a)+" b="+Stringify(b));
       document.body.innerHTML = "<big><big>CHECK_EQ FAILED!</big></big>";
       throw new Error("CHECK_EQ FAILED! a="+Stringify(a)+" b="+Stringify(b));
     }
   };
   const CHECK_GE = (a,b) => {
     if (!(a >= b)) {
       // CBB: dup code except for "EQ" vs etc
       console.log("CHECK_GE FAILED! a="+Stringify(a)+" b="+Stringify(b));
       document.body.innerHTML = "<big><big>CHECK_GE FAILED!</big></big>";
       throw new Error("CHECK_GE FAILED! a="+Stringify(a)+" b="+Stringify(b));
     }
   };
   const CHECK_LE = (a,b) => {
     if (!(a <= b)) {
       // CBB: dup code except for "EQ" vs etc
       console.log("CHECK_LE FAILED! a="+Stringify(a)+" b="+Stringify(b));
       document.body.innerHTML = "<big><big>CHECK_LE FAILED!</big></big>";
       throw new Error("CHECK_LE FAILED! a="+Stringify(a)+" b="+Stringify(b));
     }
   };

   const range = (a,b) => {
     const answer = [];
     for (let i = a; i < b; ++i) {
       answer.push(i);
     }
     return answer;
   };
   const ord = c => {
     CHECK_EQ(c.length, 1);
     return c.charCodeAt(0);
   }
   const chr = o => String.fromCharCode(o);
   const name2intvalue = name => {
     CHECK_EQ(name.length, 1);
     if (EQ(name, '')) {
       return 0;
     }
     if (ord(name) >= ord('0') && ord(name) <= ord('9')) {
       return ord(name) - ord('0');
     }
     if (ord(name) >= ord('a') && ord(name) <= ord('z')) {
       return ord(name) - ord('a') + 10;
     }
     if (ord(name) >= ord('A') && ord(name) <= ord('Z')) {
       return ord(name) - ord('A') + 10;
     }
     CHECK(false);
   };
   const intvalue2name = intvalue =>  {
     CHECK_GE(intvalue, 0);
     return intvalue>=0 && intvalue<=9 ? ''+intvalue : chr(ord('A') + intvalue-10);
   };
   const removeIf = (arr, f) => {
     let iOut = 0;
     for (let i = 0; i < arr.length; ++i) {
       if (!f(arr[i])) {
         arr[iOut++] = arr[i];
       }
     }
     arr.length = iOut;
   };
   const deepEquals = (a,b) => {
     if (a === b) return true;
     const type = typeof(a);
     CHECK(type === typeof(b));
     if (Array.isArray(a) && Array.isArray(b)) {
       if (a.length != b.length) return false;
       for (let i = 0; i < a.length; ++i) {
         if (!deepEquals(a[i], b[i])) return false;
       }
       return true;
     } else if (a instanceof Map && b instanceof Map)  {
       if (a.size != b.size) return false;
       for (const [akey,avalue] of a.entries()) {
         if (!b.has(akey)) return false;
         if (!deepEquals(b.get(akey), avalue)) return false;
       }
       return true;
     } else if (type === "string" || type === "number") {
       return false;
     } else {
       CHECK(false);
     }
   };  // deepEquals
   const deepCopy = object => {
     if (Array.isArray(object)) {
       const answer = [];
       for (let i = 0; i < object.length; ++i) {
         answer.push(deepCopy(object[i]));
       }
       return answer;
     } else if (typeof(object) === "string") {
       return object;
     } else if (typeof(object) === "number") {
       return object;
     } else {
       CHECK(false);
     }
   };  // deepCopy
   const Stringify = object => {
     if (Array.isArray(object)) {
       let answer = '[';
       for (let i = 0; i < object.length; ++i) {
         if (i > 0) answer += ', ';
         answer += Stringify(object[i]);
       }
       answer += ']';
       return answer;
     } else if (object instanceof Set) {
       let answer = "{";
       const arr = [...object];
       arr.sort();
       for (let i = 0; i < arr.length; ++i) {
         if (i > 0) answer += ', ';
         answer += Stringify(arr[i]);
       }
       answer += "}";
       return answer;
     } else if (typeof(object) === "string") {
       return JSON.stringify(object);
     } else if (typeof(object) === "number") {
       return ''+object;
     } else {
       CHECK(false);
     }
   };  // Stringify
   const Top = arr => arr[arr.length-1];

   const IsSubsetOf = (a,b) => {
     CHECK(a instanceof Set);
     CHECK(b instanceof Set);
     // TODO: is there an every() like there is for arrays?? return a.every(x=>b.has(x))
     for (const x of a) {
       if (!b.has(x)) {
         return false;
       }
     }
     return true;
   };

   // enumerate arrays of length k that are subsets of [0..n-1]
   const KSets = (n,k) => {
     CHECK(typeof(n) === 'number');
     CHECK(typeof(k) === 'number');
     if (k == 0) {
       return [[]];
     } else if (k == 1) {
       const answer = []
       for (let i = 0; i < n; ++i) answer.push([i]);
       return answer;
     } else if (k == 2) {
       const answer = []
       for (let i0 = 0; i0 < n; ++i0)
       for (let i1 = i0+1; i1 < n; ++i1)
         answer.push([i0,i1]);
       return answer;
     } else if (k == 3) {
       const answer = []
       for (let i0 = 0; i0 < n; ++i0)
       for (let i1 = i0+1; i1 < n; ++i1)
       for (let i2 = i1+1; i2 < n; ++i2)
         answer.push([i0,i1,i2]);
       return answer;
     } else if (k == 4) {
       const answer = []
       for (let i0 = 0; i0 < n; ++i0)
       for (let i1 = i0+1; i1 < n; ++i1)
       for (let i2 = i1+1; i2 < n; ++i2)
       for (let i3 = i2+1; i3 < n; ++i3)
         answer.push([i0,i1,i2,i3]);
       return answer;
     } else {
       // TODO: general
       CHECK(false);
     }
   };  // KSets

   const ExtractPrefillStringFromNYTimesOuterHTML = (outerHTML) => {
     console.log("        in ExtractPrefillStringFromNYTimesOuterHTML");
     // We use svg as a helper container,
     // because it has a getElementById method (unlike div,
     // for some strange reason).
     const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
     svg.innerHTML = outerHTML;
     console.log("  svg = ",svg);

     const cells = svg.getElementsByClassName('su-cell');
     console.log("          cells = ",cells);
     console.log("          cells.length = ",cells.length);
     const n = Math.round(Math.sqrt(Math.sqrt(cells.length)));
     CHECK_EQ(n*n*n*n, cells.length);

     let answer = '';
     for (const cell of cells) {
       const label = cell.getAttribute("aria-label");
       console.log("              label = "+Stringify(label));
       if (EQ(label, "empty")) {
         answer += "0";
       } else {
         CHECK_EQ(label.length, 1);
         answer += label;
       }
     }

     console.log("        out ExtractPrefillStringFromNYTimesOuterHTML");
     return answer;
   };  // ExtractPrefillStringFromNYTimesOuterHTML

   // Right-click on the `<div class="grid">`
   // or anything containing it, and choose Copy -> Outer HTML,
   // then save the string and feed it to this thing.
   const ExtractPrefillStringFromCrackingTheCrypticOuterHTML = (outerHTML) => {
     console.log("        in ExtractPrefillStringFromCrackingTheCrypticOuterHTML");
     // We use svg as a helper container,
     // because it has a getElementById method (unlike div,
     // for some strange reason).
     const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
     svg.innerHTML = outerHTML;
     console.log("  svg = ",svg);

     const cells = svg.getElementsByClassName('cell');
     console.log("          cells = ",cells);
     console.log("          cells.length = ",cells.length);
     const n = Math.round(Math.sqrt(Math.sqrt(cells.length)));
     CHECK_EQ(n*n*n*n, cells.length);

     // That was a good way of figuring out n,
     // but unfortunately the cells don't contain the information.
     // Look for text elements of class "cell-given" instead,
     // and we have to do presumptuous math to determine what they correspond to.

     const cell_givens = svg.getElementsByClassName('cell-given');
     console.log("          cell_givens = ",cell_givens);
     console.log("          cell_givens.length = ",cell_givens.length);
     CHECK_LE(cell_givens.length, cells.length);

     let answer = ''
     for (const cell_given of cell_givens) {
       const x = cell_given.getAttribute("x");
       const y = cell_given.getAttribute("y");
       console.log("              x="+x+" y="+y);
       // For the 9x9, anyway:
       // x=32.96 -> col=0
       // x=224.96 -> col=3
       // y=35.2 -> row=0
       // y=99.2 -> row=1
       // y=163.2 -> row=3
       // ...
       // row=0 col=0:  y=35.2 x=32.96
       const col = Math.round(x-32.96)/64;
       const row = Math.round(y-35.2)/64;
       CHECK_EQ(Math.round(col), col);
       CHECK_EQ(Math.round(row), row);
       const innerHTML = cell_given.innerHTML;
       console.log("                  col="+col+" row="+row+" innerHTML="+Stringify(innerHTML));
       CHECK_EQ(innerHTML.length, 1);
       const index = row*n*n + col;
       while (answer.length < index) answer += '0';
       answer += innerHTML;
     }
     while (answer.length < n*n) answer += '0';

     console.log("        out ExtractPrefillStringFromCrackingTheCrypticOuterHTML");
     return answer;
   };  // ExtractPrefillStringFromCrackingTheCrypticOuterHTML

   // Right-click on the `<div id="grilleJeu">`
   // or anything containing it, and choose Copy -> Outer HTML,
   // then save the string and feed it to this thing.
   const ExtractPrefillStringFrom1SudokoOuterHTML = (outerHTML) => {
     // We use svg as a helper container,
     // because it has a getElementById method (unlike div,
     // for some strange reason).
     const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
     svg.innerHTML = outerHTML;
     console.log("  svg = ",svg);
     let answer = ''
     // or, could just grab everything with class "c", I think.
     for (let i = 0; ; i++) {
       const id = "c_"+i;
       const div = svg.getElementById(id);
       if (div === null) {
         break;
       }
       //console.log("      div = ",div);
       //console.log('      div.getAttribute("v") = ',div.getAttribute("v"));
       const v = div.getAttribute("v");
       if (v != null) {
         answer += v;
       } else {
         answer += '0';
       }
     }
     return answer;
   };  // ExtractPrefillStringFrom1SudokoOuterHTML

   const PrefillString2Prefill = prefill_string => {
      const prefill_string_digits_only = prefill_string.replace(/[^0-9a-zA-Z]/g, '');
      console.log("  prefill_string_digits_only = ",prefill_string_digits_only);

      const n = Math.round(Math.sqrt(Math.sqrt(prefill_string_digits_only.length)));
      console.log("  n = ",n);
      CHECK_EQ(prefill_string_digits_only.length, n*n*n*n);
      const prefill = [];
      for (let i = 0; i < n*n*n*n; ++i) {
        prefill.push(name2intvalue(prefill_string_digits_only[i]));
      }
      console.log("  prefill = ",prefill);
      return [n,prefill];
   };  // PrefillString2Prefill

   if (true) {
     const sample = '<div id="grilleJeu"> <div id="c_0" class="c fixe" l="1" c="1" r="1" v="3"><p>3</p></div><div id="c_1" class="c" l="1" c="2" r="1"></div><div id="c_2" class="c" l="1" c="3" r="2"></div><div id="c_3" class="c fixe" l="1" c="4" r="2" v="2"><p>2</p></div><div id="c_4" class="c" l="2" c="1" r="1"></div><div id="c_5" class="c" l="2" c="2" r="1"></div><div id="c_6" class="c fixe" l="2" c="3" r="2" v="3"><p>3</p></div><div id="c_7" class="c" l="2" c="4" r="2"></div><div id="c_8" class="c" l="3" c="1" r="3"></div><div id="c_9" class="c fixe" l="3" c="2" r="3" v="4"><p>4</p></div><div id="c_10" class="c" l="3" c="3" r="4"></div><div id="c_11" class="c" l="3" c="4" r="4"></div><div id="c_12" class="c fixe" l="4" c="1" r="3" v="1"><p>1</p></div><div id="c_13" class="c" l="4" c="2" r="3"></div><div id="c_14" class="c" l="4" c="3" r="4"></div><div id="c_15" class="c" l="4" c="4" r="4"></div>            </div>';

     const prefill_string = ExtractPrefillStringFrom1SudokoOuterHTML(sample);
     console.log("  prefill_string = ",prefill_string);
     /*
     3 . . 2
     . . 3 .
     . 4 . .
     1 . . .
     <div id="grilleJeu">
       <div id="c_0" class="c fixe" l="1" c="1" r="1" v="3"><p>3</p></div>
       <div id="c_1" class="c" l="1" c="2" r="1"></div>
       <div id="c_2" class="c" l="1" c="3" r="2"></div>
       <div id="c_3" class="c fixe" l="1" c="4" r="2" v="2"><p>2</p></div>

       <div id="c_4" class="c" l="2" c="1" r="1"></div>
       <div id="c_5" class="c" l="2" c="2" r="1"></div>
       <div id="c_6" class="c fixe" l="2" c="3" r="2" v="3"><p>3</p></div>
       <div id="c_7" class="c" l="2" c="4" r="2"></div>

       <div id="c_8" class="c" l="3" c="1" r="3"></div>
       <div id="c_9" class="c fixe" l="3" c="2" r="3" v="4"><p>4</p></div>
       <div id="c_10" class="c" l="3" c="3" r="4"></div>
       <div id="c_11" class="c" l="3" c="4" r="4"></div>

       <div id="c_12" class="c fixe" l="4" c="1" r="3" v="1"><p>1</p></div>
       <div id="c_13" class="c" l="4" c="2" r="3"></div>
       <div id="c_14" class="c" l="4" c="3" r="4"></div>
       <div id="c_15" class="c" l="4" c="4" r="4"></div>
     </div>'
     */
   }




   console.log("in script");
   console.log("  window.location = ",window.location);
   console.log("  window.location.href = ",window.location.href);

   let n = 3;  // standard puzzle: 3x3x3x3

   let prefill = undefined;

   if (true) {
     //const url_param_prefill = '003020600.900305001.001806400.008102900.700000008.006708200.002609500.800203009.005010300';
     //
     // An "easy" 16x16 puzzle from https://1sudoku.com/sudoku-variants/super-sudoku-16x16
     //

       /*
       const url_param_prefill = (
         '_EG3_F9__24_da7_' +
         'DB_6A______CE_F2' +
         '_28_74e1db5a_6G_' +
         '__a____dg____B__' +
         '3______79______g' +
         '_A61_GC__8F_42D_' +
         '_854________6EA_' +
         '____BA_45_6E____' +
         '____29_84_c7____' +
         '_518________2g9_' +
         '_3fd_cg__51_87e_' +
         '4______3e______5' +
         '__d____23____5__' +
         '_62_g34EFAD5_C1_' +
         '_c35_8F__72_gd6_' +
         'a1_F5______87_23' +
         ''
       ).replace(/_/g, '0').toLowerCase();
       */

     //const url_param_prefill = '1000.0200.0030.0004';  // unsolvable
     //const url_param_prefill = '1300.0200.0030.0004';  // solvable
     //const url_param_prefill = '1300.0200.0030.0000';  // unsolvable
     //const url_param_prefill = '1300.0000.0032.0000';  // solvable

     let url_param_prefill = new URL(window.location.href).searchParams.get("prefill");

     //const url_param_prefill = ExtractPrefillStringFrom1SudokoOuterHTML('<div id="grilleJeu"> <div id="c_0" class="c fixe" l="1" c="1" r="1" v="A"><p>3</p></div><div id="c_1" class="c" l="1" c="2" r="1"></div><div id="c_2" class="c" l="1" c="3" r="2"></div><div id="c_3" class="c fixe" l="1" c="4" r="2" v="2"><p>2</p></div><div id="c_4" class="c" l="2" c="1" r="1"></div><div id="c_5" class="c" l="2" c="2" r="1"></div><div id="c_6" class="c fixe" l="2" c="3" r="2" v="3"><p>3</p></div><div id="c_7" class="c" l="2" c="4" r="2"></div><div id="c_8" class="c" l="3" c="1" r="3"></div><div id="c_9" class="c fixe" l="3" c="2" r="3" v="4"><p>4</p></div><div id="c_10" class="c" l="3" c="3" r="4"></div><div id="c_11" class="c" l="3" c="4" r="4"></div><div id="c_12" class="c fixe" l="4" c="1" r="3" v="1"><p>1</p></div><div id="c_13" class="c" l="4" c="2" r="3"></div><div id="c_14" class="c" l="4" c="3" r="4"></div><div id="c_15" class="c" l="4" c="4" r="4"></div>            </div>');

     console.log("  url_param_prefill = ",url_param_prefill);

     if (url_param_prefill[0] == 'p') {
       // Get it out of file_contents
       const found = url_param_prefill.match(/^.*[^0-9]([0-9]+)$/);
       console.log("  found = ",found);
       const puzzle_number = parseInt(found[1]);
       console.log("  puzzle_number = ",puzzle_number);
       const puzzle_numeral = ''+((puzzle_number-puzzle_number%10)/10)+(puzzle_number%10);

       const what_to_look_for = "Grid "+puzzle_numeral+"\n";
       console.log("  what_to_look_for = ",what_to_look_for);
       const index = file_contents.indexOf(what_to_look_for);
       console.log("  index = ",index);
       CHECK_GE(index, 0);
       url_param_prefill = ''
       for (let i = index + what_to_look_for.length; i < file_contents.length && url_param_prefill.length < 81; ++i) {
         if (file_contents[i] >= '0' && file_contents[i] <= '9') {
           url_param_prefill += file_contents[i];
         }
       }
       console.log("  url_param_prefill = ",url_param_prefill);

       if (true) {
         // Make "prev" and "next" links
         if (puzzle_number > 1) {
           const scratch = new URL(window.location.href);
           scratch.searchParams.set("prefill", "p"+(puzzle_number-1));
           document.body.innerHTML += '<a href="'+scratch.href+'">prev</a>';
         }
         if (puzzle_number < 50) {
           const scratch = new URL(window.location.href);
           scratch.searchParams.set("prefill", "p"+(puzzle_number+1));
           document.body.innerHTML += ' <a href="'+scratch.href+'">next</a>';
         }
       }
     }
    [n,prefill] = PrefillString2Prefill(url_param_prefill);

   } else {
     prefill = [];
     for (let i = 0; i < n*n*n*n; ++i) {
       prefill.push(0);
     }
   }





   const PopulateIt = prefill => {
     let the_table = document.getElementsByClassName("toplevel_table");
     the_table.innerHTML = '';  // clear it, for starters

     console.log("  the_table = ",the_table);
     CHECK_EQ(the_table.length, 1);
     the_table = the_table[0];
     console.log("  the_table = ",the_table);

     let table_inner_html = ''
     for (let i = 0; i < n*n; ++i) {
       const after_divider_maybe = i!=0 && i%n==0 ? " after_divider" : "";
       table_inner_html += '<tr class="toplevel_row'+after_divider_maybe+'">'
       for (let j = 0; j < n*n; ++j) {
         const after_divider_maybe = j!=0 && j%n==0 ? " after_divider" : "";
         const prefilled_maybe = prefill[i*n*n+j] != 0 ? " prefilled" : "";
         table_inner_html += ' <td class="cell'+after_divider_maybe+prefilled_maybe+'">';
       }
     }

     the_table.innerHTML = table_inner_html;

     const cells = document.getElementsByClassName("cell");
     CHECK_EQ(cells.length, n*n*n*n);


     // State will be a list of candidates for each cell.
     const state = [];
     for (let i = 0; i < n*n; ++i) {
       state.push([]);
       for (let j = 0; j < n*n; ++j) {
         if (prefill[i*n*n+j] == 0) {
           state[i].push(range(1,n*n+1));
           //console.log("  range(1,n*n+1) = ",range(1,n*n+1));
         } else {
           state[i].push([prefill[i*n*n+j]]);
         }
       }
     }

     const all_houses = [];
     {
       for (let i = 0; i < n*n; ++i) {
         all_houses.push([]);
         for (let j = 0; j < n*n; ++j) Top(all_houses).push([i,j]);
       }
       for (let j = 0; j < n*n; ++j) {
         all_houses.push([]);
         for (let i = 0; i < n*n; ++i) Top(all_houses).push([i,j]);
       }
       for (let ii = 0; ii < n; ++ii) {
         for (let jj = 0; jj < n; ++jj) {
           all_houses.push([]);
           for (let iii = 0; iii < n; ++iii) {
             for (let jjj = 0; jjj < n; ++jjj) {
               Top(all_houses).push([ii*n+iii, jj*n+jjj]);
             }
           }
         }
       }
     }
     const coords2houses = [];
     {
       for (let i = 0; i < n*n; ++i) {
         coords2houses.push([]);
         for (let j = 0; j < n*n; ++j) {
           Top(coords2houses).push([]);
         }
       }
       for (let ihouse = 0; ihouse < all_houses.length; ++ihouse) {
         for (let iinhouse = 0; iinhouse < n*n; ++iinhouse) {
           const coord = all_houses[ihouse][iinhouse];
           coords2houses[coord[0]][coord[1]].push(ihouse);
         }
       }
     }
     console.log("  initial state = ",state);
     return [n,state,cells,[],[],all_houses,coords2houses];
   };  // PopulateIt

   let [state,cells,undoStack,redoStack,all_houses,coords2houses] = [undefined];
   [n, state,cells,undoStack,redoStack,all_houses,coords2houses] = PopulateIt(prefill);



   // Propagate singles to eliminate candidates.
   const propagateSingles = (n, state) => {
     console.log("      in propagateSingles(n="+n+", state)");
     const originalState = deepCopy(state);  // TODO: this is silly. make states unmutable instead
     for (let i = 0; i < n*n; ++i) {
       for (let j = 0; j < n*n; ++j) {
         if (originalState[i][j].length == 1) {
           // same row
           //console.log("      state["+i+"]["+j+"] is a singleton "+originalState[i][j][0]+"; lasering");
           for (let k = 0; k < n*n; ++k) {
             if (k != j) {
               removeIf(state[i][k], x => x===originalState[i][j][0]);
             }
           }
           for (let k = 0; k < n*n; ++k) {
             if (k != i) {
               removeIf(state[k][j], x => x===originalState[i][j][0]);
             }
           }
           for (let ii = 0; ii < n; ++ii) {
             for (let jj = 0; jj < n; ++jj) {
               if (ii != i%n || jj != j%n) {
                 removeIf(state[i-i%n+ii][j-j%n+jj], x=>x===originalState[i][j][0]);
               }
             }
           }
         }
       }
     }
     console.log("      out propagateSingles(n="+n+", state)");
   };  // propagateSingles

   const doHiddenSingles = (n, state) => {
     const verbose_level = 1;
     if (verbose_level >= 1) console.log("        in doHiddenSingles(n="+n+", state)");
     if (verbose_level >= 2) console.log("          state = "+Stringify(state));
     const originalState = deepCopy(state);  // TODO: this is silly. make states unmutable instead
     if (verbose_level >= 2) console.log("          originalState = "+Stringify(originalState));
     // For each digit and house (i.e. row, column, or block),
     // if there's only one place the digit can go
     // in that house, then put it there
     // (i.e. remove all other candidates in that cell).
     if (verbose_level >= 2) console.log("          all_houses = "+Stringify(all_houses));

     for (let digit = 1; digit <= n*n; ++digit) {
       if (verbose_level >= 2) console.log("              digit = "+digit);
       for (let ihouse = 0; ihouse < all_houses.length; ++ihouse) {
         const candidatePositionsInHouse = [];
         const XXXsuperdebug = digit==4 && ihouse == 19;
         for (let iinhouse = 0; iinhouse < all_houses[ihouse].length; ++iinhouse) {
           const coords = all_houses[ihouse][iinhouse];
           if (originalState[coords[0]][coords[1]].includes(digit)) {
             candidatePositionsInHouse.push(iinhouse);
           }
         }
         if (candidatePositionsInHouse.length === 1) {
           if (verbose_level >= 2) console.log("                  digit "+intvalue2name(digit)+" can go in only position "+candidatePositionsInHouse[0]+":"+all_houses[ihouse][candidatePositionsInHouse[0]]+" in house "+ihouse+" = "+Stringify(all_houses[ihouse]));
           const coords = all_houses[ihouse][candidatePositionsInHouse[0]];
           state[coords[0]][coords[1]].length = 1;
           state[coords[0]][coords[1]][0] = digit;
         }
       }
     }

     if (verbose_level >= 1) console.log("        out doHiddenSingles(n="+n+", state)");
   };  // doHiddenSingles

   const doNakedTuples = (tuplicity, n, state) => {
     const verbose_level = 1;
     if (verbose_level >= 1) console.log("        in doNakedTuples(tuplicity="+tuplicity+", n="+n+", state)");
     const originalState = deepCopy(state);  // TODO: this is silly. make states unmutable instead

     // What is a naked pair?  It's when two cells in a house
     // have the exact same candidates.  In this case we can eliminate
     // those two candidates from the rest of the house.

     // What is a naked triple?  It's when three cells in a house
     // have the same three candidates, although it may be that only
     // two of them occur at a time.  E.g.
     //   123 123 12
     //   12 13 23
     // In that case we can eliminate these three candidates from
     // the rest of the house.

     for (let ihouse = 0; ihouse < all_houses.length; ++ihouse) {
       if (verbose_level >= 2) console.log("            ihouse = "+ihouse+" = "+Stringify(all_houses[ihouse]));

       const iindicesOfNonSingles = [];
       for (let iinhouse = 0; iinhouse < n*n; ++iinhouse) {
         const coords = all_houses[ihouse][iinhouse];
         if (originalState[coords[0]][coords[1]].length >= 2) {
          iindicesOfNonSingles.push(iinhouse);
         }
       }
       // CBB: probably very inefficient, especially when no naked singles
       // in the house
       const ksets = KSets(iindicesOfNonSingles.length, tuplicity);
       for (const kset of ksets) {
         const union = new Set();
         for (const i of kset) {
           const iinhouse = iindicesOfNonSingles[i];
           const coords = all_houses[ihouse][iinhouse];
           for (const digit of originalState[coords[0]][coords[1]]) {
             union.add(digit);
           }
         }
         if (union.size == tuplicity) {
           if (verbose_level >= 2) console.log("                    found naked "+tuplicity+"-tuple "+Stringify(union)+" in house "+ihouse+" non-single positions "+Stringify(kset));
           // remove the digits in the union from the rest of this house.
           for (let i = 0; i < iindicesOfNonSingles.length; ++i) {
             if (!kset.includes(i)) {
               const iinhouse = iindicesOfNonSingles[i];
               const coords = all_houses[ihouse][iinhouse];
               removeIf(state[coords[0]][coords[1]], x => union.has(x));
             }
           }
         }
       }

      }
     if (verbose_level >= 1) console.log("        out doNakedTuples(tuplicity="+tuplicity+", n="+n+", state)");
   };  // doNakedTuples

   const doHiddenTuples = (tuplicity, n, state) => {
     const verbose_level = 1;
     if (verbose_level >= 1) console.log("        in doHiddenTuples(tuplicity="+tuplicity+", n="+n+", state)");
     const originalState = deepCopy(state);  // TODO: this is silly. make states unmutable instead
     for (let ihouse = 0; ihouse < all_houses.length; ++ihouse) {
       if (verbose_level >= 3) console.log("            ihouse = "+ihouse+" = "+Stringify(all_houses[ihouse]));

       // What exactly is a hidden pair?
       // It's a pair of digits such that each of them occurs only twice
       // in the house, in the same place.

       // What exactly is a hidden triple?
       // Well, it's 3 different digits
       // whose union spans only 3 different cells in this house.
       // (and none of them should be naked singles)

       const definitelyUninterestingDigits = new Set();
       for (let coords of all_houses[ihouse]) {
         const originalStateCell = originalState[coords[0]][coords[1]];
         if (originalStateCell.length == 1) {
           definitelyUninterestingDigits.add(originalStateCell[0]);
         }
       }

       // CBB: should be array indexed by digit, but the 1-basing makes it awkward
       const digit2indicesInHouse = new Map();
       for (let digit = 1; digit <= n*n; ++digit) {
         if (definitelyUninterestingDigits.has(digit)) continue;
         digit2indicesInHouse.set(digit, []);
       }
       for (let iinhouse = 0; iinhouse < n*n; ++iinhouse) {
         const coords = all_houses[ihouse][iinhouse];
         for (const digit of originalState[coords[0]][coords[1]]) {
           if (definitelyUninterestingDigits.has(digit)) continue;
           digit2indicesInHouse.get(digit).push(iinhouse);
         }
       }

       const interesting_digits = [];
       for (let digit = 1; digit <= n*n; ++digit) {
         if (definitelyUninterestingDigits.has(digit)) continue;
         if (digit2indicesInHouse.get(digit).length >= 2 &&
             digit2indicesInHouse.get(digit).length <= tuplicity) {
           interesting_digits.push(digit);
         }
       }
       if (verbose_level >= 3) console.log("                interesting_digits = "+Stringify(interesting_digits));

       const ksets = KSets(interesting_digits.length, tuplicity);
       if (verbose_level >= 2) console.log("                ksets = "+Stringify(ksets));;
       for (const kset of ksets) {
         const tuple = kset.map(i=>interesting_digits[i]);
         if (verbose_level >= 3) console.log("                considering tuple of digits "+Stringify(tuple));
         const union = new Set();
         for (const digit of tuple) {
           for (const iinhouse of digit2indicesInHouse.get(digit)) {
             union.add(iinhouse);
           }
         }
         if (verbose_level >= 3) console.log("                    union = "+Stringify(union));
         if (union.size == tuplicity) {
           if (verbose_level >= 2) console.log("                    found hidden (or maybe already naked) "+tuplicity+"-tuple "+Stringify(tuple)+" in house "+ihouse+" positions "+Stringify(union));
           // Make this tuple naked, by removing everything except
           // the specific digits.
           for (const iinhouse of union) {
             const coords = all_houses[ihouse][iinhouse];
             removeIf(state[coords[0]][coords[1]], x => !tuple.includes(x));
           }
         }
       }
     }
     if (verbose_level >= 1) console.log("        out doHiddenTuples(tuplicity="+tuplicity+", n="+n+", state)");
   };  // doHiddenTuples

   const doOmissions = (n, state) => {
     const verbose_level = 1;
     if (verbose_level >= 1) console.log("        in doOmissions(n="+n+", state)");
     const originalState = deepCopy(state);  // TODO: this is silly. make states unmutable instead

     // When a given digit's occurrances (candidacies) in house A
     // is limited to an intersecting house B,
     // then that digit can be eliminated from the rest of house B.
     // (one of A or B will be a block, the other will be a row or
     // column)

     for (let digit = 1; digit <= n*n; ++digit) {
       if (verbose_level >= 2) console.log("          digit = "+digit);
       const house2coordKeysContainingDigit = new Map();
       {
         for (let ihouse = 0; ihouse < all_houses.length; ++ihouse) {
           for (let iinhouse = 0; iinhouse < all_houses[ihouse].length; ++iinhouse) {
             const coords = all_houses[ihouse][iinhouse];
             if (originalState[coords[0]][coords[1]].includes(digit)) {
               const coordKey = ''+coords;
               if (!house2coordKeysContainingDigit.has(ihouse)) house2coordKeysContainingDigit.set(ihouse, new Set());
               house2coordKeysContainingDigit.get(ihouse).add(coordKey);
             }
           }
         }
       }

       for (const [ihouse0,coordKeys0] of house2coordKeysContainingDigit.entries()) {
         for (const [ihouse1,coordKeys1] of house2coordKeysContainingDigit.entries()) {
           if (ihouse0 == ihouse1) continue;
           if (coordKeys0.size == 1) continue;  // this is already covered under lone single or something

           // Are all occurrances of digit in house0 also in house1?
           if (IsSubsetOf(coordKeys0, coordKeys1)) {
             if (verbose_level >= 2) console.log("              Hey! every occurrance of digit "+digit+" in house "+ihouse0+" is also in "+ihouse1);
             if (verbose_level >= 2) console.log("                  coordKeys0 = "+Array.from(coordKeys0));
             if (verbose_level >= 2) console.log("                  coordKeys1 = "+Array.from(coordKeys1));
             // Remove all other occurrances of digit in house1.
             for (let iinhouse1 = 0; iinhouse1 < all_houses[ihouse1].length; ++iinhouse1) {
               const coords = all_houses[ihouse1][iinhouse1];
               if (originalState[coords[0]][coords[1]].includes(digit) &&
                   !coords2houses[coords[0]][coords[1]].includes(ihouse0)) {
                 if (verbose_level >= 2) console.log("                      so can remove the "+digit+" at "+Stringify(coords));
                 removeIf(state[coords[0]][coords[1]], x => x===digit);
               }
             }
           }
         }
       }
     }

     if (verbose_level >= 1) console.log("        out doOmissions(n="+n+", state)");
   };  // doOmissions


   const propagateSinglesButton = document.getElementsByClassName("propagatesingles")[0];
   const hiddenSinglesButton = document.getElementsByClassName("hiddensingles")[0];
   const nakedPairsButton = document.getElementsByClassName("nakedpairs")[0];
   const hiddenPairsButton = document.getElementsByClassName("hiddenpairs")[0];
   const nakedTriplesButton = document.getElementsByClassName("nakedtriples")[0];
   const hiddenTriplesButton = document.getElementsByClassName("hiddentriples")[0];
   const nakedQuadsButton = document.getElementsByClassName("nakedquads")[0];
   const hiddenQuadsButton = document.getElementsByClassName("hiddenquads")[0];
   const omissionButton = document.getElementsByClassName("omission")[0];
   const undoButton = document.getElementsByClassName("undo")[0];
   const redoButton = document.getElementsByClassName("redo")[0];
   const propagateSinglesCountSpan = document.getElementsByClassName("propagatesinglescount")[0];
   const doHiddenSinglesCountSpan = document.getElementsByClassName("dohiddensinglescount")[0];
   const doNakedPairsCountSpan = document.getElementsByClassName("donakedpairscount")[0];
   const doHiddenPairsCountSpan = document.getElementsByClassName("dohiddenpairscount")[0];
   const doNakedTriplesCountSpan = document.getElementsByClassName("donakedtriplescount")[0];
   const doHiddenTriplesCountSpan = document.getElementsByClassName("dohiddentriplescount")[0];
   const doNakedQuadsCountSpan = document.getElementsByClassName("donakedquadscount")[0];
   const doHiddenQuadsCountSpan = document.getElementsByClassName("dohiddenquadscount")[0];
   const doOmissionsCountSpan = document.getElementsByClassName("doomissionscount")[0];
   const undoStackSizeSpan = document.getElementsByClassName("undostacksize")[0];
   const redoStackSizeSpan = document.getElementsByClassName("redostacksize")[0];

   const howManyTimesStateWillChange = (state,changeState) => {
     let answer = 0;
     while (true) {
       const newState = deepCopy(state);
       changeState(newState);
       if (deepEquals(state, newState)) {
         break;
       }
       ++answer;
       state = newState;
     }
     return answer;
   };  // howManyTimesStateWillChange

   // This must be separate from updateUiFromStatePair: we do *not* want
   // to do it on mousedown, since that will prevent recognizing mouseup!
   const updateUndoRedoButtons = () => {
     undoButton.disabled = (undoStack.length === 0);
     redoButton.disabled = (redoStack.length === 0);
     undoStackSizeSpan.innerHTML = ''+undoStack.length;
     redoStackSizeSpan.innerHTML = ''+redoStack.length;
     const nPropagates = howManyTimesStateWillChange(state, scratchState=>propagateSingles(n,scratchState))
     const nDoHiddenSingles = howManyTimesStateWillChange(state, scratchState=>doHiddenSingles(n,scratchState));
     const nDoNakedPairs = howManyTimesStateWillChange(state, scratchState=>doNakedTuples(2,n,scratchState));
     const nDoHiddenPairs = howManyTimesStateWillChange(state, scratchState=>doHiddenTuples(2,n,scratchState));
     const nDoNakedTriples = howManyTimesStateWillChange(state, scratchState=>doNakedTuples(3,n,scratchState));
     const nDoHiddenTriples = howManyTimesStateWillChange(state, scratchState=>doHiddenTuples(3,n,scratchState));
     const nDoNakedQuads = howManyTimesStateWillChange(state, scratchState=>doNakedTuples(4,n,scratchState));
     const nDoHiddenQuads = howManyTimesStateWillChange(state, scratchState=>doHiddenTuples(4,n,scratchState));
     const nDoOmissions = howManyTimesStateWillChange(state, scratchState=>doOmissions(n,scratchState));

     propagateSinglesButton.disabled = nPropagates===0;
     hiddenSinglesButton.disabled = nDoHiddenSingles===0;
     nakedPairsButton.disabled = nDoNakedPairs===0;
     hiddenPairsButton.disabled = nDoHiddenPairs===0;
     nakedTriplesButton.disabled = nDoNakedTriples===0;
     hiddenTriplesButton.disabled = nDoHiddenTriples===0;
     nakedQuadsButton.disabled = nDoNakedQuads===0;
     hiddenQuadsButton.disabled = nDoHiddenQuads===0;
     omissionButton.disabled = nDoOmissions===0;

     propagateSinglesCountSpan.innerHTML = ''+nPropagates;
     doHiddenSinglesCountSpan.innerHTML = ''+nDoHiddenSingles;
     doNakedPairsCountSpan.innerHTML = ''+nDoNakedPairs;
     doHiddenPairsCountSpan.innerHTML = ''+nDoHiddenPairs;
     doNakedTriplesCountSpan.innerHTML = ''+nDoNakedTriples;
     doHiddenTriplesCountSpan.innerHTML = ''+nDoHiddenTriples;
     doNakedQuadsCountSpan.innerHTML = ''+nDoNakedQuads;
     doHiddenQuadsCountSpan.innerHTML = ''+nDoHiddenQuads;
     doOmissionsCountSpan.innerHTML = ''+nDoOmissions;
   };

   // Show common stuff in black, appearing stuff in green, disappearing stuff in red
   const updateUiFromStatePair = (state0,state1) => {
     CHECK(Array.isArray(state0));
     CHECK(Array.isArray(state1));
     for (let i = 0; i < n*n; ++i) {
       for (let j = 0; j < n*n; ++j) {
         if (state0[i][j].length === 1 &&
             state1[i][j].length === 1 &&
             state0[i][j][0] == state1[i][j][0]) {
           const intvalue = state0[i][j][0];
           const charvalue = intvalue2name(intvalue);
           cells[i*n*n+j].innerHTML = charvalue;
         } else {
           let cell_inner_html = '';
           cell_inner_html += '<table>'

           for (let subi = 0; subi < n; ++subi) {
             cell_inner_html += '<tr>'
             for (let subj = 0; subj < n; ++subj) {
               cell_inner_html += '<td class="pencil">'
               const intvalue = subi*n+subj+1;
               const includes0 = state0[i][j].includes(intvalue);
               const includes1 = state1[i][j].includes(intvalue);
               if (includes0 || includes1) {
                 const color = !includes0 ? '#00c000' : !includes1 ? 'red' : 'black';
                 const weight = !includes0 || !includes1 ? 'bold' : 'normal';
                 cell_inner_html += '<span style="font-weight:'+weight+'; color:'+color+';">';
                 // TODO: make it so size doesn't jump, and do this <big> thing!
                 //if (!includes0 || !includes1) { cell_inner_html += '<big>'; }
                 cell_inner_html += '' + intvalue2name(intvalue);
                 //if (!includes0 || !includes1) { cell_inner_html += '</big>'; }
                 cell_inner_html += '</span>';
               }
             }
           }
           cell_inner_html += '</table>'
           cells[i*n*n+j].innerHTML = cell_inner_html;
         }
       }
     }
   };  // updateUiFromStatePair

   updateUiFromStatePair(state,state);
   updateUndoRedoButtons();

   const propagateSinglesButtonMouseOver = () => {
     console.log("    in propagateSinglesButtonMouseOver");
     const scratchState = deepCopy(state);
     propagateSingles(n, scratchState);
     updateUiFromStatePair(state,scratchState);
     console.log("    out propagateSinglesButtonMouseOver");
   };
   const propagateSinglesButtonMouseDown = () => {
     console.log("    in propagateSinglesButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     redoStack.length = 0;  // clear
     undoStack.push(deepCopy(state));
     propagateSingles(n, state);
     updateUiFromStatePair(Top(undoStack),state);
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out propagateSinglesButtonMouseDown");
   };

   const hiddenSinglesButtonMouseOver = () => {
     console.log("    in propagateSinglesButtonMouseOver");
     const scratchState = deepCopy(state);
     doHiddenSingles(n, scratchState);
     updateUiFromStatePair(state,scratchState);
     console.log("    out propagateSinglesButtonMouseOver");
   };
   const hiddenSinglesButtonMouseDown = () => {
     console.log("    in hiddenSinglesButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     redoStack.length = 0;  // clear
     undoStack.push(deepCopy(state));
     doHiddenSingles(n, state);
     updateUiFromStatePair(Top(undoStack),state);
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out hiddenSinglesButtonMouseDown");
   };

   const nakedPairsButtonMouseOver = () => {
     console.log("    in nakedPairsButtonMouseOver");
     const scratchState = deepCopy(state);
     doNakedTuples(2, n, scratchState);
     updateUiFromStatePair(state,scratchState);
     console.log("    out nakedPairsButtonMouseOver");
   };
   const nakedPairsButtonMouseDown = () => {
     console.log("    in nakedPairsButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     redoStack.length = 0;  // clear
     undoStack.push(deepCopy(state));
     doNakedTuples(2, n, state);
     updateUiFromStatePair(Top(undoStack),state);
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out nakedPairsButtonMouseDown");
   };

   const nakedTriplesButtonMouseOver = () => {
     console.log("    in nakedTriplesButtonMouseOver");
     const scratchState = deepCopy(state);
     doNakedTuples(3, n, scratchState);
     updateUiFromStatePair(state,scratchState);
     console.log("    out nakedTriplesButtonMouseOver");
   };
   const nakedTriplesButtonMouseDown = () => {
     console.log("    in nakedTriplesButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     redoStack.length = 0;  // clear
     undoStack.push(deepCopy(state));
     doNakedTuples(3, n, state);
     updateUiFromStatePair(Top(undoStack),state);
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out nakedTriplesButtonMouseDown");
   };

   const hiddenTriplesButtonMouseOver = () => {
     console.log("    in hiddenTriplesButtonMouseOver");
     const scratchState = deepCopy(state);
     doHiddenTuples(3, n, scratchState);
     updateUiFromStatePair(state,scratchState);
     console.log("    out hiddenTriplesButtonMouseOver");
   };
   const hiddenTriplesButtonMouseDown = () => {
     console.log("    in hiddenTriplesButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     redoStack.length = 0;  // clear
     undoStack.push(deepCopy(state));
     doHiddenTuples(3, n, state);
     updateUiFromStatePair(Top(undoStack),state);
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out hiddenTriplesButtonMouseDown");
   };

   const nakedQuadsButtonMouseOver = () => {
     console.log("    in nakedQuadsButtonMouseOver");
     const scratchState = deepCopy(state);
     doNakedTuples(4, n, scratchState);
     updateUiFromStatePair(state,scratchState);
     console.log("    out nakedQuadsButtonMouseOver");
   };
   const nakedQuadsButtonMouseDown = () => {
     console.log("    in nakedQuadsButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     redoStack.length = 0;  // clear
     undoStack.push(deepCopy(state));
     doNakedTuples(4, n, state);
     updateUiFromStatePair(Top(undoStack),state);
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out nakedQuadsButtonMouseDown");
   };

   const hiddenQuadsButtonMouseOver = () => {
     console.log("    in hiddenQuadsButtonMouseOver");
     const scratchState = deepCopy(state);
     doHiddenTuples(4, n, scratchState);
     updateUiFromStatePair(state,scratchState);
     console.log("    out hiddenQuadsButtonMouseOver");
   };
   const hiddenQuadsButtonMouseDown = () => {
     console.log("    in hiddenQuadsButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     redoStack.length = 0;  // clear
     undoStack.push(deepCopy(state));
     doHiddenTuples(4, n, state);
     updateUiFromStatePair(Top(undoStack),state);
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out hiddenQuadsButtonMouseDown");
   };

   const hiddenPairsButtonMouseOver = () => {
     console.log("    in hiddenPairsButtonMouseOver");
     const scratchState = deepCopy(state);
     doHiddenTuples(2, n, scratchState);
     updateUiFromStatePair(state,scratchState);
     console.log("    out hiddenPairsButtonMouseOver");
   };
   const hiddenPairsButtonMouseDown = () => {
     console.log("    in hiddenPairsButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     redoStack.length = 0;  // clear
     undoStack.push(deepCopy(state));
     doHiddenTuples(2, n, state);
     updateUiFromStatePair(Top(undoStack),state);
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out hiddenPairsButtonMouseDown");
   };

   const omissionButtonMouseOver = () => {
     console.log("    in propagateSinglesButtonMouseOver");
     const scratchState = deepCopy(state);
     doOmissions(n, scratchState);
     updateUiFromStatePair(state,scratchState);
     console.log("    out propagateSinglesButtonMouseOver");
   };
   const omissionButtonMouseDown = () => {
     console.log("    in omissionButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     redoStack.length = 0;  // clear
     undoStack.push(deepCopy(state));
     doOmissions(n, state);
     updateUiFromStatePair(Top(undoStack),state);
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out omissionButtonMouseDown");
   };

   const undoButtonMouseDown = () => {
     console.log("    in undoButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     if (undoStack.length >= 1) {
       redoStack.push(state);
       state = undoStack.pop();
       // It seems to be less confusing if we show
       // undos in the same color as the do's/redo's,
       // even though they are doing the opposite thing.
       updateUiFromStatePair(state, Top(redoStack));
     } else {
       // This shouldn't ever happen because the button should be disabled
       // when there's nothing to undo.
       console.log("      nothing to undo!");
     }
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out undoButtonMouseDown");
   };
   const redoButtonMouseDown = () => {
     console.log("    in redoButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     if (redoStack.length >= 1) {
       undoStack.push(state);
       state = redoStack.pop();
       updateUiFromStatePair(Top(undoStack), state);
     } else {
       // This shouldn't ever happen because the button should be disabled
       // when there's nothing to redo.
       console.log("      nothing to redo!");
     }
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out redoButtonMouseDown");
   };

   const anyButtonMouseOut = () => {
     console.log("    in anyButtonMouseOut");
     updateUiFromStatePair(state,state);
     console.log("    out anyButtonMouseOut");
   };
   const anyButtonMouseUp = () => {
     console.log("    in anyButtonMouseUp");
     updateUiFromStatePair(state,state);
     updateUndoRedoButtons();
     console.log("    out anyButtonMouseUp");
   };

   const resetButtonClicked = () => {
     console.log("    in resetButtonClicked");

     //const prefill_string = '1300020000300004';

     const prefill_input = document.getElementById("prefill");
     console.log("      prefill_input = ",prefill_input);
     CHECK(prefill_input != null);
     console.log("      prefill_input.innerHTML = ",prefill_input.innerHTML);
     console.log("      prefill_input.value = ",prefill_input.value);

     const outerHTML = prefill_input.value;

     let prefill_string;
     if (outerHTML.indexOf('grilleJeu') != -1) {
       prefill_string = ExtractPrefillStringFrom1SudokoOuterHTML(outerHTML)
     } else if (outerHTML.indexOf('div class="grid"') != -1 &&
                outerHTML.indexOf('div class="cells"') != -1 &&
                outerHTML.indexOf('id="cell-givens"') != -1) {
       prefill_string = ExtractPrefillStringFromCrackingTheCrypticOuterHTML(outerHTML);
     } else if (outerHTML.indexOf('div role="grid" class="su-board"') != -1 ||
                outerHTML.indexOf('class="su-cell') != -1) {
       // reason for checking for su-cell
       // is in case someone grepped for that in the output
       // before pasting: if they paste the whole grid thing,
       // it's too huge :-(
       prefill_string = ExtractPrefillStringFromNYTimesOuterHTML(outerHTML);
     } else {
       // TODO: more graceful rejection than this!
       // Actually validate and color green/red accordingly!
       CHECK(false);
     }

     [n,prefill] = PrefillString2Prefill(prefill_string);
     console.log("      prefill = ",prefill);
     [n,state,cells,undoStack,redoStack,all_houses,coords2houses] = PopulateIt(prefill);
     updateUiFromStatePair(state,state);
     updateUndoRedoButtons();
     console.log("    out resetButtonClicked");
   };  // resetButtonClicked

   const inputKeyDown = (event) => {
     console.log("    in inputKeyDown");
     console.log("      event = ",event);
     if (EQ(event.key, "Enter")) {
       // hack
       resetButtonClicked();
     }
     console.log("    out inputKeyDown");
   };  // inputKeyDown

   //console.log("  file_contents = ",file_contents);
   console.log("out script");
 </script>
</html>
