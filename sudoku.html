<!--
TODO: make it so size doesn't jump, and do the <big> thing
TODO: get mouse-up right (need to listen on window I think)
TODO: show the red/green on hover?  (then maybe don't need down/up)
TODO: get prefill from url param
TODO: make easy way to get prefills from the projecteuler file
TODO: show how many button presses of each type will succeed?

TODONE: disable buttons when they would do nothing

-->
<html>
 <head>
  <style>
   table.toplevel_table {
    border:5px solid black;
    border-collapse:collapse;
    border-spacing:0px;
   }
   tr.after_divider {
     border-top:3px solid gray;
   }
   td.cell.after_divider {
     border-left:3px solid gray;
   }
   td.cell.prefilled {
    background:#e6e6e6;  /* nytimes is #e6e6e6 */
   }
   td.cell { 
    border:1px solid gray; 
    padding:0px; 
    margin:0px; 
    /* 55 seems to be what is used by nytimes, maybe */
    width:75px;
    height:75px;
    text-align:center;
    font-size:200%;  /* XXX hack for now, should get something more principled */
    font-weight:bold;
   }
   td.pencil {
    text-align:center;
    font-size:100%;  /* XXX hack for now, should get something more principled */
    /* XXX this is very unprincipled; sizes don't add up, and it works for only n=3 */
    width:20px;
    height:20px;
    color:black;
   }
  </style>
 </head>
 <body>
  <table>
    <tr>
      <td>
       <table class='toplevel_table'>
        <!-- to be filled in by javascript -->
       </table>
      <td>
       <table>
        <tr>
         <td><input class="propagatesingles" type="button" value="Propagate singles" onmouseover="propagateSinglesButtonMouseOver()" onmouseout="propagateSinglesButtonMouseOut()" onmousedown="propagateSinglesButtonMouseDown()" onmouseup="propagateSinglesButtonMouseUp()">
         <small><small><span class="propagatesinglescount"></span></small></small>
        <tr>
         <td><input class="hiddensingles" type="button" value="Hidden singles" onmouseover="hiddenSinglesButtonMouseOver()" onmouseout="hiddenSinglesButtonMouseOut()" onmousedown="hiddenSinglesButtonMouseDown()" onmouseup="hiddenSinglesButtonMouseUp()">
         <small><small><span class="dohiddensinglescount"></span></small></small>
        <tr>
         <td><input class="nakedpairs" type="button" value="Naked pairs" onmouseover="nakedPairsButtonMouseOver()" onmouseout="nakedPairsButtonMouseOut()" onmousedown="nakedPairsButtonMouseDown()" onmouseup="nakedPairsButtonMouseUp()">
         <small><small><span class="donakedpairscount"></span></small></small>
        <tr>
         <td><input class="undo" type="button" value="Undo" onmousedown="undoButtonMouseDown()" onmouseup="undoButtonMouseUp()">
         <small><small><span class="undostacksize">0</span></small></small>
        <tr>
         <td><input class="redo" type="button" value="Redo" onmousedown="redoButtonMouseDown()" onmouseup="redoButtonMouseUp()">
         <small><small><span class="redostacksize">0</span></small></small>
       </table>
   <table>


 </body>
 <script src="projecteuler_p096_sudoku.txt.js"></script>
 <script>
   const CHECK = cond => {
     if (!cond) {
       console.log("CHECK FAILED!");
       document.body.innerHTML = "<big><big>CHECK FAILED!</big></big>";
       throw new Error("CHECK FAILED!");
     }
   };
   const range = (a,b) => {
     const answer = [];
     for (let i = a; i < b; ++i) {
       answer.push(i);
     }
     return answer;
   };
   const ord = c => {
     CHECK(c.length === 1);
     return c.charCodeAt(0);
   }
   const chr = o => String.fromCharCode(o);
   const name2intvalue = name => {
     CHECK(name.length === 1);
     if (name === '0') {
       return '';
     }
     if (ord(name) >= ord('0') && ord(name) <= ord('9')) {
       return ord(name) - ord('0');
     }
     if (ord(name) >= ord('a') && ord(name) <= ord('z')) {
       return ord(name) - ord('a') + 10;
     }
     if (ord(name) >= ord('A') && ord(name) <= ord('Z')) {
       return ord(name) - ord('a') + 10;
     }
     CHECK(false);
   };
   const intvalue2name = intvalue =>  {
     return intvalue<=9 ? ''+intvalue : chr(ord('a') + intvalue-10);
   };
   const removeIf = (arr, f) => {
     for (let i = 0; i < arr.length; ++i) {
       if (f(arr[i])) {
         arr.splice(i, 1);
         i--;
       }
     }
   };
   const deepEquals = (a,b) => {
     if (Array.isArray(a) && Array.isArray(b)) {
       if (a.length != b.length) return false;
       for (let i = 0; i < a.length; ++i) {
         if (!deepEquals(a[i], b[i])) return false;
       }
       return true;
     } else if (typeof(a) === "number" && typeof(b) === "number") {
       return a === b;
     } else {
       CHECK(false);
     }
   };  // deepEquals
   const deepCopy = object => {
     if (Array.isArray(object)) {
       const answer = [];
       for (let i = 0; i < object.length; ++i) {
         answer.push(deepCopy(object[i]));
       }
       return answer;
     } else if (typeof(object) === "number") {
       return object;
     } else {
       CHECK(false);
     }
   };  // deepCopy
   const Stringify = object => {
     if (Array.isArray(object)) {
       let answer = '[';
       for (let i = 0; i < object.length; ++i) {
         if (i > 0) answer += ', ';
         answer += Stringify(object[i]);
       }
       answer += ']';
       return answer;
     } else if (typeof(object) === "number") {
       return ''+object;
     } else {
       CHECK(false);
     }
   };  // Stringify
   const Top = arr => arr[arr.length-1];


   console.log("in script");
   console.log("  window.location = ",window.location);
   console.log("  window.location.href = ",window.location.href);

   let n = 3;  // standard puzzle: 3x3x3x3

   let prefill = undefined;

   if (true) {
     //const url_param_prefill = '003020600.900305001.001806400.008102900.700000008.006708200.002609500.800203009.005010300';
     //const url_param_prefill = '1000.0200.0030.0004';
     let url_param_prefill = new URL(window.location.href).searchParams.get("prefill");
     console.log("  url_param_prefill = ",url_param_prefill);

     if (url_param_prefill[0] == 'p') {
       // Get it out of file_contents
       const found = url_param_prefill.match(/^.*[^0-9]([0-9]+)$/);
       console.log("  found = ",found);
       const puzzle_number = parseInt(found[1]);
       console.log("  puzzle_number = ",puzzle_number);
       const what_to_look_for = "Grid "+((puzzle_number-puzzle_number%10)/10)+(puzzle_number%10)+"\n";
       console.log("  what_to_look_for = ",what_to_look_for);
       const index = file_contents.indexOf(what_to_look_for);
       console.log("  index = ",index);
       CHECK(index >= 0);
       url_param_prefill = ''
       for (let i = index + what_to_look_for.length; i < file_contents.length && url_param_prefill.length < 81; ++i) {
         if (file_contents[i] >= '0' && file_contents[i] <= '9') {
           url_param_prefill += file_contents[i];
         }
       }
       console.log("  url_param_prefill = ",url_param_prefill);
     }

     const prefill_digits_only = url_param_prefill.replace(/[^0-9a-zA-Z]/g, '');
     console.log("  prefill_digits_only = ",prefill_digits_only);

     n = Math.round(Math.sqrt(Math.sqrt(prefill_digits_only.length)));
     console.log("  n = ",n);
     CHECK(prefill_digits_only.length == n*n*n*n);
     prefill = [];
     for (let i = 0; i < n*n*n*n; ++i) {
       prefill.push(name2intvalue(prefill_digits_only[i]));
     }
     console.log("  prefill = ",prefill);
   } else {
     prefill = [];
     for (let i = 0; i < n*n*n*n; ++i) {
       prefill.push(0);
     }
   }



   let the_table = document.getElementsByClassName("toplevel_table");
   console.log("  the_table = ",the_table);
   CHECK(the_table.length === 1);
   the_table = the_table[0];
   console.log("  the_table = ",the_table);

   let table_inner_html = ''
   for (let i = 0; i < n*n; ++i) {
     const after_divider_maybe = i!=0 && i%n==0 ? " after_divider" : "";
     table_inner_html += '<tr class="toplevel_row'+after_divider_maybe+'">'
     for (let j = 0; j < n*n; ++j) {
       const after_divider_maybe = j!=0 && j%n==0 ? " after_divider" : "";
       const prefilled_maybe = prefill[i*n*n+j] != 0 ? " prefilled" : "";
       table_inner_html += ' <td class="cell'+after_divider_maybe+prefilled_maybe+'">';
     }
   }

   the_table.innerHTML = table_inner_html;

   const cells = document.getElementsByClassName("cell");
   CHECK(cells.length === n*n*n*n);


   // State will be a list of candidates for each cell.
   let state = [];
   for (let i = 0; i < n*n; ++i) {
     state.push([]);
     for (let j = 0; j < n*n; ++j) {
       if (prefill[i*n*n+j] == 0) {
         state[i].push(range(1,n*n+1));
         //console.log("  range(1,n*n+1) = ",range(1,n*n+1));
       } else {
         state[i].push([prefill[i*n*n+j]]);
       }
     }
   }
   console.log("  initial state = ",state);

   // Propagate singles to eliminate candidates.
   const propagateSingles = (n, state) => {
     console.log("      in propagateSingles(n="+n+", state)");
     const originalState = deepCopy(state);  // TODO: this is silly. make states unmutable instead
     for (let i = 0; i < n*n; ++i) {
       for (let j = 0; j < n*n; ++j) {
         if (originalState[i][j].length == 1) {
           // same row
           //console.log("      state["+i+"]["+j+"] is a singleton "+originalState[i][j][0]+"; lasering");
           for (let k = 0; k < n*n; ++k) {
             if (k != j) {
               removeIf(state[i][k], x => x===originalState[i][j][0]);
             }
           }
           for (let k = 0; k < n*n; ++k) {
             if (k != i) {
               removeIf(state[k][j], x => x===originalState[i][j][0]);
             }
           }
           for (let ii = 0; ii < n; ++ii) {
             for (let jj = 0; jj < n; ++jj) {
               if (ii != i%n || jj != j%n) {
                 removeIf(state[i-i%n+ii][j-j%n+jj], x=>x===originalState[i][j][0]);
               }
             }
           }
         }
       }
     }
     console.log("      out propagateSingles(n="+n+", state)");
   };  // propagateSingles

   const all_houses = [];
   {
     for (let i = 0; i < n*n; ++i) {
       all_houses.push([]);
       for (let j = 0; j < n*n; ++j) Top(all_houses).push([i,j]);
     }
     for (let j = 0; j < n*n; ++j) {
       all_houses.push([]);
       for (let i = 0; i < n*n; ++i) Top(all_houses).push([i,j]);
     }
     for (let ii = 0; ii < n; ++ii) {
       for (let jj = 0; jj < n; ++jj) {
         all_houses.push([]);
         for (let iii = 0; iii < n; ++iii) {
           for (let jjj = 0; jjj < n; ++jjj) {
             Top(all_houses).push([ii*n+iii, jj*n+jjj]);
           }
         }
       }
     }
   }


   const doHiddenSingles = (n, state) => {
     const verbose_level = 1;
     if (verbose_level >= 1) console.log("        in doHiddenSingles(n="+n+", state)");
     const originalState = deepCopy(state);  // TODO: this is silly. make states unmutable instead
     // For each digit and house (i.e. row, column, or block),
     // if there's only one place the digit can go
     // in that house, then put it there
     // (i.e. remove all other candidates in that cell).
     if (verbose_level >= 2) console.log("          all_houses = "+Stringify(all_houses));

     for (let digit = 1; digit <= n*n; ++digit) {
       if (verbose_level >= 2) console.log("              digit = "+digit);
       for (let ihouse = 0; ihouse < all_houses.length; ++ihouse) {
         const candidatePositionsInHouse = [];
         const XXXsuperdebug = digit==4 && ihouse == 19;
         for (let iinhouse = 0; iinhouse < all_houses[ihouse].length; ++iinhouse) {
           const coords = all_houses[ihouse][iinhouse];
           if (originalState[coords[0]][coords[1]].includes(digit)) {
             candidatePositionsInHouse.push(iinhouse);
           }
         }
         if (candidatePositionsInHouse.length === 1) {
           if (verbose_level >= 2) console.log("                  digit "+intvalue2name(digit)+" can go in only position "+candidatePositionsInHouse[0]+":"+all_houses[ihouse][candidatePositionsInHouse[0]]+" in house "+ihouse+" = "+Stringify(all_houses[ihouse]));
           const coords = all_houses[ihouse][candidatePositionsInHouse[0]];
           state[coords[0]][coords[1]].length = 1;
           state[coords[0]][coords[1]][0] = digit;
         }
       }
     }

     if (verbose_level >= 1) console.log("            out doHiddenSingles(n="+n+", state)");
   };  // doHiddenSingles

   const doNakedPairs = (n, state) => {
     const verbose_level = 1;
     if (verbose_level >= 1) console.log("        in doNakedPairs(n="+n+", state)");
     const originalState = deepCopy(state);  // TODO: this is silly. make states unmutable instead


     if (verbose_level >= 1) console.log("            out doNakedPairs(n="+n+", state)");
   };  // doNakedPairs




   const undoStack = [];
   const redoStack = [];
   const propagateSinglesButton = document.getElementsByClassName("propagatesingles")[0];
   const hiddenSinglesButton = document.getElementsByClassName("hiddensingles")[0];
   const nakedPairsButton = document.getElementsByClassName("nakedpairs")[0];
   const undoButton = document.getElementsByClassName("undo")[0];
   const redoButton = document.getElementsByClassName("redo")[0];
   const propagateSinglesCountSpan = document.getElementsByClassName("propagatesinglescount")[0];
   const doHiddenSinglesCountSpan = document.getElementsByClassName("dohiddensinglescount")[0];
   const doNakedPairsCountSpan = document.getElementsByClassName("donakedpairscount")[0];
   const undoStackSizeSpan = document.getElementsByClassName("undostacksize")[0];
   const redoStackSizeSpan = document.getElementsByClassName("redostacksize")[0];

   const howManyTimesStateWillChange = (state,changeState) => {
     let answer = 0;
     while (true) {
       const newState = deepCopy(state);
       changeState(newState);
       if (deepEquals(state, newState)) {
         break;
       }
       ++answer;
       state = newState;
     }
     return answer;
   };  // howManyTimesStateWillChange

   // This must be separate from updateUiFromStatePair: we do *not* want
   // to do it on mousedown, since that will prevent recognizing mouseup!
   const updateUndoRedoButtons = () => {
     undoButton.disabled = (undoStack.length === 0);
     redoButton.disabled = (redoStack.length === 0);
     undoStackSizeSpan.innerHTML = ''+undoStack.length;
     redoStackSizeSpan.innerHTML = ''+redoStack.length;
     const nPropagates = howManyTimesStateWillChange(state, scratchState=>propagateSingles(n,scratchState))
     const nDoHiddens = howManyTimesStateWillChange(state, scratchState=>doHiddenSingles(n,scratchState));
     const nDoNakedPairs = howManyTimesStateWillChange(state, scratchState=>doNakedPairs(n,scratchState));
     propagateSinglesButton.disabled = nPropagates===0;
     hiddenSinglesButton.disabled = nDoHiddens===0;
     nakedPairsButton.disabled = nDoNakedPairs===0;
     propagateSinglesCountSpan.innerHTML = ''+nPropagates;
     doHiddenSinglesCountSpan.innerHTML = ''+nDoHiddens;
     doNakedPairsCountSpan.innerHTML = ''+nDoNakedPairs;
   };

   // Show common stuff in black, appearing stuff in green, disappearing stuff in red
   const updateUiFromStatePair = (state0,state1) => {
     CHECK(Array.isArray(state0));
     CHECK(Array.isArray(state1));
     for (let i = 0; i < n*n; ++i) {
       for (let j = 0; j < n*n; ++j) {
         if (state0[i][j].length === 1 &&
             state1[i][j].length === 1 &&
             state0[i][j][0] == state1[i][j][0]) {
           const intvalue = state0[i][j][0];
           const charvalue = intvalue2name(intvalue);
           cells[i*n*n+j].innerHTML = charvalue;
         } else {
           let cell_inner_html = '';
           cell_inner_html += '<table>'

           for (let subi = 0; subi < n; ++subi) {
             cell_inner_html += '<tr>'
             for (let subj = 0; subj < n; ++subj) {
               cell_inner_html += '<td class="pencil">'
               const intvalue = subi*n+subj+1;
               const includes0 = state0[i][j].includes(intvalue);
               const includes1 = state1[i][j].includes(intvalue);
               if (includes0 || includes1) {
                 const color = !includes0 ? '#00c000' : !includes1 ? 'red' : 'black';
                 const weight = !includes0 || !includes1 ? 'bold' : 'normal';
                 cell_inner_html += '<span style="font-weight:'+weight+'; color:'+color+';">';
                 // TODO: make it so size doesn't jump, and do this <big> thing!
                 //if (!includes0 || !includes1) { cell_inner_html += '<big>'; }
                 cell_inner_html += '' + intvalue2name(intvalue);
                 //if (!includes0 || !includes1) { cell_inner_html += '</big>'; }
                 cell_inner_html += '</span>';
               }
             }
           }
           cell_inner_html += '</table>'
           cells[i*n*n+j].innerHTML = cell_inner_html;
         }
       }
     }
   };  // updateUiFromStatePair

   if (false) {
     // Just exercise it
     undoStack.push(deepCopy(state));
     state = undoStack.pop();
   }
   updateUiFromStatePair(state,state);
   updateUndoRedoButtons();

   const propagateSinglesButtonMouseOver = () => {
     console.log("    in propagateSinglesButtonMouseOver");
     const scratchState = deepCopy(state);
     propagateSingles(n, scratchState);
     updateUiFromStatePair(state,scratchState);
     console.log("    out propagateSinglesButtonMouseOver");
   };
   const propagateSinglesButtonMouseOut = () => {
     console.log("    in propagateSinglesButtonMouseOut");
     updateUiFromStatePair(state,state);
     console.log("    out propagateSinglesButtonMouseOut");
   };
   const propagateSinglesButtonMouseDown = () => {
     console.log("    in propagateSinglesButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     redoStack.length = 0;  // clear
     undoStack.push(deepCopy(state));
     propagateSingles(n, state);
     updateUiFromStatePair(Top(undoStack),state);
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out propagateSinglesButtonMouseDown");
   };
   const propagateSinglesButtonMouseUp = () => {
     console.log("    in propagateSinglesButtonMouseUp");
     updateUiFromStatePair(state,state);
     updateUndoRedoButtons();
     console.log("    out propagateSinglesButtonMouseUp");
   };
   const hiddenSinglesButtonMouseOver = () => {
     console.log("    in propagateSinglesButtonMouseOver");
     const scratchState = deepCopy(state);
     doHiddenSingles(n, scratchState);
     updateUiFromStatePair(state,scratchState);
     console.log("    out propagateSinglesButtonMouseOver");
   };
   const hiddenSinglesButtonMouseOut = () => {
     console.log("    in propagateSinglesButtonMouseOut");
     updateUiFromStatePair(state,state);
     console.log("    out propagateSinglesButtonMouseOut");
   };
   const hiddenSinglesButtonMouseDown = () => {
     console.log("    in hiddenSinglesButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     redoStack.length = 0;  // clear
     undoStack.push(deepCopy(state));
     doHiddenSingles(n, state);
     updateUiFromStatePair(Top(undoStack),state);
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out hiddenSinglesButtonMouseDown");
   };
   const hiddenSinglesButtonMouseUp = () => {
     console.log("    in hiddenSinglesButtonMouseUp");
     updateUiFromStatePair(state,state);
     updateUndoRedoButtons();
     console.log("    out hiddenSinglesButtonMouseUp");
   };
   const undoButtonMouseDown = () => {
     console.log("    in undoButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     if (undoStack.length >= 1) {
       redoStack.push(state);
       state = undoStack.pop();
       // It seems to be less confusing if we show
       // undos in the same color as the do's/redo's,
       // even though they are doing the opposite thing.
       updateUiFromStatePair(state, Top(redoStack));
     } else {
       // This shouldn't ever happen because the button should be disabled
       // when there's nothing to undo.
       console.log("      nothing to undo!");
     }
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out undoButtonMouseDown");
   };
   const undoButtonMouseUp = () => {
     console.log("    in undoButtonMouseUp");
     updateUiFromStatePair(state,state);
     updateUndoRedoButtons();
     console.log("    out undoButtonMouseUp");
   };
   const redoButtonMouseDown = () => {
     console.log("    in redoButtonMouseDown");
     console.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     if (redoStack.length >= 1) {
       undoStack.push(state);
       state = redoStack.pop();
       updateUiFromStatePair(Top(undoStack), state);
     } else {
       // This shouldn't ever happen because the button should be disabled
       // when there's nothing to redo.
       console.log("      nothing to redo!");
     }
     console.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
     console.log("    out redoButtonMouseDown");
   };
   const redoButtonMouseUp = () => {
     console.log("    in redoButtonMouseUp");
     updateUiFromStatePair(state,state);
     updateUndoRedoButtons();
     console.log("    out redoButtonMouseUp");
   };

   //console.log("  file_contents = ",file_contents);
   console.log("out script");
 </script>
</html>
