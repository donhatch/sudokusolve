<!--

TODO: should not require clicking in order to paste; give the thing focus automatically on mouseover (or something)

TODO: can I put the myconsole in a separate window, instead of fighting with it in the same window?

TODO: sometimes there are prefills that do not include some digit,
      so I can't hover over it to do the red/green.
      need some way to do that.

TODO:
  (jellyfish example on hodoku, taken from pure jellyfish on forum)
  2....358.....2...1...4.56.....9.4.68..5.1.9..61.8.2.....15.8...3...4.....263....4
  do the naked singles and hidden pair;
  why is "naked pair" wanting to remove the 7 at r7c8?  I don't see that being a naked pair.


https://www.sudokuoftheday.com/techniques/swordfish/
195367248
.78.5.369
3.6.98157
..378.59.
7.9..5..6
5849.671.
832549671
9.7.13.25
.51.729..

TODO: get fish size ui sorted out, it's very confusing and not very usable.
      maybe:
        - there should be a swordfish button, that does nothing unless there is a swordfish that is NOT involved in singles or doubles
          except... hmm, the way I do decomposition messes things up, it makes it appear that a swordfish appears, prematurely.
          So, need to do some special logic to make sure we don't sieze the swordfish prematurely.

TODO: http://forum.enjoysudoku.com/a-pure-swordfish-collection-t5775.html consensus seems to be that TTHsieh's
      second proposal has an xwing, not a swordfish.  which is weird because my program
      does *not* seem to think it's an xwing, wtf?
      That thread didn't seem to pan out :-( )
      Oh wait, maybe it did, there is more than one page...

TODO: http://hodoku.sourceforge.net/en/show_example.php?file=bf301&tech=Swordfish says "The following representation can be pasted in most Soduku programs:"

TODO: actually make a nice user-solve mode
- should be able to easily navigate stack of stuff that is done and consequences
  examined, vs done and consequences not yet examined.
  Hmm, how will that look?

TODO: digit-examination mode, that quickly shows all remaining candidacies of a digit.
        green: definitely
        light green: maybe
        light red: definitely not

TODO: switch to notation like they use in forum: http://forum.enjoysudoku.com/a-pure-swordfish-collection-t5775.html
      not sure whether it's used with a program, but the important thing
      is that blanks are '.'s.

      Really should be able to copy-paste right out of it.


TODO: swordfish.
  examples:
    T-Rex ttps://www.youtube.com/watch?v=12lPDRFXhYs at 19:46 and 23:20

    ... ... ...    .5. .5. .5.
    ... ... ...    ... ... ...
    .7. .7. .7.    .5. .5. .5.

    ... ... ...    ... .5. .5.
    ... ... ...    ... ... ...
    .7. ... .7.    ... ... ...

    ... ... ...    ... ... ...
    ... ... ...    ... ... ...
    ... .7. .7.    ... ... ...
  interesting thread (maybe; I don't understand the forum yet)
  which includes enumeration of lots of techniques
    http://forum.enjoysudoku.com/a-pure-swordfish-collection-t5775.html

  Q: hmm, it mentions 1000 isomorphs of puzzle.   how is that?
  PA:
       9! digit permutations (although can just canonicalize here? not sure)
       6 row-of-blocks permutations
     * 6*6*6 row permutations within each row-of-blocks
       and same for columns


TODO: T-Rex by Macrovius
  https://www.youtube.com/watch?v=12lPDRFXhYs
  Also talks about Tatooine sunset
  - ey used 8 different swordfishes?
    but could have used a new technique called MSLS (multi sector locked sets)
    which is the one being shown here.
    wait wtf? the video doesn't talk about it?  maybe that's in another video?
    I think maybe this one?
      https://www.youtube.com/watch?v=TQ0lso4fJzk

  - "10:20 or so: nobody puts 9s in the corner of the grid" ??
    - hmm something more about that here https://www.youtube.com/watch?v=GrLVkH122XU

TODO: huh! doesn't solve this one:
    https://app.crackingthecryptic.com/sudoku/94Qq6qGjh2
    ("classic sudoku") (mark's favorite sudoku ever).  why does he say the 8's are not an x-wing?  they sure seem like one.

  - he used something interesting at 6:30-
    Q: is it covered by the techniques I
    have coded so far?
    What's happening is:
      6,3,8 all have only 3 left in a block, and it's the *same* 3
      in that block.  that's a hidden triple, or something?  think
      about it.
    A: yes, it's a hidden triple.
    At 14:30, he's got as far as my solver gets.  So, after that,
    he needs to do something very clever.
    Yes, it's a swordfish!  Which I haven't learned yet.

  - wait, or maybe this is mark's favorite?
      https://www.youtube.com/watch?v=IFHOtse62Jo
      https://app.crackingthecryptic.com/sudoku/B42dn4M8pn
      - at 13:30 or so, he mentions that you should do two things
        with a hidden pair.  am I doing them both?

TODO: is there yet another xwing type thing that interacts between all three of row,col,block?  yes, I think so.  Hmm!
                1.. .1.
                .1. .1.
                ... ...

TODO: simplify xwing if possible- - too many cases with similar looking code, currently
TODO: longer xwing chains
TODO: split up xwing button according to type, so its less confusing. it's really hard to tell what it's thinking currently.
TODO: try to figure out how to draw the xwings on hover-over!

TODO: better way to input nytimes puzzle----  it's too long and the input text thing chokes!  (maybe it's because editing history?)

TODO: distinguish between naked single pencilled, and penned.
TODO: think about whether it makes sense to auto-update candidates
      (i.e. the naked single thing).
      hover: show result of move
      down: do move, show result of updating candidates
      up: update the candidates
      That might work nicely!
      Idea: when down, i.e. move done and showing result of updating candidates, maybe use 2 different colors for about-to-remove and remove? hmm.

TODO: layout flashing at beginning because no table.  can I fix that??
TODO: refactor to make the states immutable
TODO: make it so size doesn't jump, and do the <big> thing
TODO: get mouse-up right (need to listen on window I think)
TODO: show the red/green on hover?  (then maybe don't need down/up)
TODO: show how many button presses of each type will succeed?
TODO: don't do hidden quads that are uninteresting due to pending naked singles, since it looks dorky to have that button enabled at start

TODO: get prefill from url param  (hmm, maybe not useful? not sure)

TODONE: make easy way to get prefills from the projecteuler file (hard coded)
TODONE: disable buttons when they would do nothing

TODO: research more advanced strategies?
      e.g. referred to on https://krazydad.com/hexsudoku/ :
      X-Wing, XY-Wing, Swordfish



TODO: find a way to input puzzles from sites such as https://1sudoku.com/sudoku-variants/super-sudoku-16x16

-->
<html>
 <head>
  <style>
   .myconsole {
     height:300px;
     border:1px solid black;
     overflow: auto;
     font-size:small;  /* seems to be same size as console font */
     /* act like pre, but use div instead of pre since pre adds unfriendly extra space afterwards */
     font-family:monospace;
     white-space:pre;
   }
   table.toplevel_table {
    border:5px solid black;
    border-collapse:collapse;
    border-spacing:0px;
   }
   tr.after_divider {
     border-top:3px solid gray;
   }
   td.cell.after_divider {
     border-left:3px solid gray;
   }
   td.cell.prefilled {
    background:#e6e6e6;  /* nytimes is #e6e6e6 */
   }
   td.cell {
    border:1px solid gray;
    padding:0px;
    margin:0px;
    /* 55 seems to be what is used by nytimes, maybe */
    width:75px;
    height:75px;
    text-align:center;
    font-size:200%;  /* XXX hack for now, should get something more principled */
    font-weight:bold;
   }
   td.pencil {
    text-align:center;
    font-size:100%;  /* XXX hack for now, should get something more principled */
    /* XXX this is very unprincipled; sizes don't add up, and it works for only n=3 */
    width:20px;
    height:20px;
    color:black;
   }
   .prefill {
     font-size:small;
   }
  </style>
 </head>
 <body>
  <table>
   <span id="thinking">started</span>
   <tr>
    <td>
     <table class='toplevel_table'>
      <!-- to be filled in by javascript -->
     </table>

    <td>
     <table>

      <tr>
       <td><input class="propagatesingles" type="button" value="Propagage naked singles" onmouseover="propagateSinglesButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="propagateSinglesButtonMouseDown()" onmouseup="anyButtonMouseUp()">
       <small><small><span class="propagatesinglescount"></span></small></small>

      <tr>
       <td><input class="hiddensingles" type="button" value="Hidden singles" onmouseover="hiddenSinglesButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="hiddenSinglesButtonMouseDown()" onmouseup="anyButtonMouseUp()">
       <small><small><span class="dohiddensinglescount"></span></small></small>

      <tr>
       <td><input class="nakedpairs" type="button" value="Naked pairs" onmouseover="nakedPairsButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="nakedPairsButtonMouseDown()" onmouseup="anyButtonMouseUp()">
       <small><small><span class="donakedpairscount"></span></small></small>

      <tr>
       <td><input class="hiddenpairs" type="button" value="Hidden pairs" onmouseover="hiddenPairsButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="hiddenPairsButtonMouseDown()" onmouseup="anyButtonMouseUp()">
       <small><small><span class="dohiddenpairscount"></span></small></small>

      <tr>
       <td><input class="nakedtriples" type="button" value="Naked triples" onmouseover="nakedTriplesButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="nakedTriplesButtonMouseDown()" onmouseup="anyButtonMouseUp()">
       <small><small><span class="donakedtriplescount"></span></small></small>

      <tr>
       <td><input class="hiddentriples" type="button" value="Hidden triples" onmouseover="hiddenTriplesButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="hiddenTriplesButtonMouseDown()" onmouseup="anyButtonMouseUp()">
       <small><small><span class="dohiddentriplescount"></span></small></small>

      <tr>
       <td><input class="nakedquads" type="button" value="Naked quads" onmouseover="nakedQuadsButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="nakedQuadsButtonMouseDown()" onmouseup="anyButtonMouseUp()">
       <small><small><span class="donakedquadscount"></span></small></small>

      <tr>
       <td><input class="hiddenquads" type="button" value="Hidden quads" onmouseover="hiddenQuadsButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="hiddenQuadsButtonMouseDown()" onmouseup="anyButtonMouseUp()">
       <small><small><span class="dohiddenquadscount"></span></small></small>

      <tr>
       <td><input class="omission" type="button" value="Omission/intersection/pointing/blocking/claiming" onmouseover="omissionButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="omissionButtonMouseDown()" onmouseup="anyButtonMouseUp()">
       <small><small><span class="doomissionscount"></span></small></small>

      <tr>
       <td><input class="xwing" type="button" value="X-wing and similar" onmouseover="xwingButtonMouseOver()" onmouseout="anyButtonMouseOut()" onmousedown="xwingButtonMouseDown()" onmouseup="anyButtonMouseUp()">
       <small><small><span class="doxwingscount"></span></small></small>

      <tr>
       <td>
         Row-column fish:
         <input class="fish1" type="button" value="1" title="every 1-fish can be obtained by simply baring a hidden single and propagating from it, I think" onmouseover="fishButtonMouseOver(1)" onmouseout="anyButtonMouseOut()" onmousedown="fishButtonMouseDown(1)" onmouseup="anyButtonMouseUp()">
         <small><small><span class="dofish1scount"></span></small></small>
         <input class="fish2" type="button" value="2" title="2-fishes are the same as x-wings... I think" onmouseover="fishButtonMouseOver(2)" onmouseout="anyButtonMouseOut()" onmousedown="fishButtonMouseDown(2)" onmouseup="anyButtonMouseUp()">
         <small><small><span class="dofish2scount"></span></small></small>
         <input class="fish3" type="button" value="3" title="3-fishes are swordfish" onmouseover="fishButtonMouseOver(3)" onmouseout="anyButtonMouseOut()" onmousedown="fishButtonMouseDown(3)" onmouseup="anyButtonMouseUp()">
         <small><small><span class="dofish3scount"></span></small></small>
         <input class="fish4" type="button" value="4" title="4-fishes are jellyfish" onmouseover="fishButtonMouseOver(4)" onmouseout="anyButtonMouseOut()" onmousedown="fishButtonMouseDown(4)" onmouseup="anyButtonMouseUp()">
         <small><small><span class="dofish4scount"></span></small></small>

      <tr>
       <td><input class="undo" type="button" value="Undo" onmousedown="undoButtonMouseDown()" onmouseup="anyButtonMouseUp()">
       <small><small><span class="undostacksize">0</span></small></small>

      <tr>
       <td><input class="redo" type="button" value="Redo" onmousedown="redoButtonMouseDown()" onmouseup="anyButtonMouseUp()">
       <small><small><span class="redostacksize">0</span></small></small>

      <!-- XXX HACK to get the buttons higher.  TODO: top-justify them -->
      <tr>
       <td><hr>

      <tr>
       <td>
         <input class="redo" type="button" value="Reset to pasted from text (or html from crackingthecryptic.com/1sudoko.com/nytimes.com/latimes.com):" onclick="resetButtonClicked()" onpaste="myconsole.log(.pasted on button')"></input>
         <br>
         <textarea id="prefill" class="prefill" rows="26" cols="65" onkeydown="inputKeyDown(event)" onpaste="inputPasted(event)"></textarea>
     </table>
   </table>
   <span id="prevlink"></span>
   <span id="nextlink"></span>
   <br>
   <input type="button" value="Clear log" onmousedown="myconsole.clear()"></input>
   <input type="button" value="Log separator" onmousedown="myconsole.log('------------------------------------------------------------------------------------------------------------')"></input>
   <div id="myconsole" class="myconsole">DEBUGGING CONSOLE<br></div>
   <small><small><span id="myconsolelinecount" class="myconsolelinecount">0</span> log lines</small></small>
 </body>
 <script src="projecteuler_p096_sudoku.txt.js"></script>
 <script src="myconsole.js"></script>
 <script>
   "use strict";

   // strict equality, but enforce that they are the same type
   // (instead of just returning false if they aren't).
   const EQ = (a,b) => {
     if (a === b) return true;
     CHECK(typeof(a) == typeof(b));
     return false;
   };
   const CHECK = cond => {
     if (!cond) {
       console.error("CHECK FAILED!");
       document.body.innerHTML = "<big><big>CHECK FAILED! See javascript console for details.</big></big>";
       throw new Error("CHECK FAILED!");
     }
   };
   const CHECK_EQ = (a,b) => {
     if (!(a === b)) {
       // CBB: dup code except for "EQ" vs etc
       // CBB: sometimes it would be better to use `,` instead of `+` to take advantage of console's stringification.  but sometimes not.
       console.error("CHECK_EQ a===b FAILED! a="+Stringify(a)+" b="+Stringify(b));
       document.body.innerHTML = "<big><big>CHECK_EQ FAILED! See javascript console for details.</big></big>";
       throw new Error("CHECK_EQ a===b FAILED! a="+Stringify(a)+" b="+Stringify(b));
     }
   };
   const CHECK_GE = (a,b) => {
     if (!(a >= b)) {
       // CBB: dup code except for "EQ" vs etc
       console.error("CHECK_GE a>=b FAILED! a="+Stringify(a)+" b="+Stringify(b));
       document.body.innerHTML = "<big><big>CHECK_GE FAILED! See javascript console for details.</big></big>";
       throw new Error("CHECK_GE a>=b FAILED! a="+Stringify(a)+" b="+Stringify(b));
     }
   };
   const CHECK_LE = (a,b) => {
     if (!(a <= b)) {
       // CBB: dup code except for "EQ" vs etc
       document.body.innerHTML = "<big><big>CHECK_LE FAILED! See javascript console for details.</big></big>";
       document.body.innerHTML = "<big><big>CHECK_LE a<=b FAILED!</big></big>";
       throw new Error("CHECK_LE a<=b FAILED! a="+Stringify(a)+" b="+Stringify(b));
     }
   };

   // like python's range
   // TODO: actually make it a generator
   const range = (a,b) => {
     if (b === undefined) {
       // range(n) is range(0,n)
       [a,b] = [0,a];
     }
     const answer = [];
     for (let i = a; i < b; ++i) {
       answer.push(i);
     }
     return answer;
   };

   const ord = c => {
     CHECK_EQ(c.length, 1);
     return c.charCodeAt(0);
   }
   const chr = o => String.fromCharCode(o);
   const name2intvalue = name => {
     CHECK_EQ(name.length, 1);
     if (EQ(name, '')) {
       return 0;
     }
     if (ord(name) >= ord('0') && ord(name) <= ord('9')) {
       return ord(name) - ord('0');
     }
     if (ord(name) >= ord('a') && ord(name) <= ord('z')) {
       return ord(name) - ord('a') + 10;
     }
     if (ord(name) >= ord('A') && ord(name) <= ord('Z')) {
       return ord(name) - ord('A') + 10;
     }
     CHECK(false);
   };
   const intvalue2name = intvalue =>  {
     CHECK_GE(intvalue, 0);
     return intvalue>=0 && intvalue<=9 ? ''+intvalue : chr(ord('A') + intvalue-10);
   };
   const removeIf = (arr, f) => {
     let iOut = 0;
     for (let i = 0; i < arr.length; ++i) {
       if (!f(arr[i])) {
         arr[iOut++] = arr[i];
       }
     }
     arr.length = iOut;
   };
   const SortedArrayMinus = (a,b) => {
     // simple to express way
     const bSet = new Set(b);
     const answer = [];
     for (let x of a) {
       if (!bSet.has(x)) answer.push(x);
     }
     return answer;
   };  // SortedArrayMinus

   const deepEquals = (a,b) => {
     if (a === b) return true;
     const type = typeof(a);
     CHECK(type === typeof(b));
     if (Array.isArray(a) && Array.isArray(b)) {
       if (a.length != b.length) return false;
       for (let i = 0; i < a.length; ++i) {
         if (!deepEquals(a[i], b[i])) return false;
       }
       return true;
     } else if (a instanceof Map && b instanceof Map)  {
       if (a.size != b.size) return false;
       for (const [akey,avalue] of a.entries()) {
         if (!b.has(akey)) return false;
         if (!deepEquals(b.get(akey), avalue)) return false;
       }
       return true;
     } else if (type === "string" || type === "number") {
       return false;
     } else {
       CHECK(false);
     }
   };  // deepEquals
   const deepCopy = object => {
     if (Array.isArray(object)) {
       const answer = [];
       for (let i = 0; i < object.length; ++i) {
         answer.push(deepCopy(object[i]));
       }
       return answer;
     } else if (typeof(object) === "string") {
       return object;
     } else if (typeof(object) === "number") {
       return object;
     } else {
       CHECK(false);
     }
   };  // deepCopy
   const Stringify = object => {
     if (object === undefined) {
       return "undefined";
     } else if (object === null) {
       return "null";
     } else if (Array.isArray(object)) {
       let answer = '[';
       for (let i = 0; i < object.length; ++i) {
         if (i > 0) answer += ', ';
         answer += Stringify(object[i]);
       }
       answer += ']';
       return answer;
     } else if (object instanceof Set) {
       let answer = "{";
       const arr = [...object];
       arr.sort();
       for (let i = 0; i < arr.length; ++i) {
         if (i > 0) answer += ', ';
         answer += Stringify(arr[i]);
       }
       answer += "}";
       return answer;
     } else if (typeof(object) === "string") {
       return JSON.stringify(object);
     } else if (typeof(object) === "number") {
       return ''+object;
     } else {
       console.error("woops, trying to Stringify something of type "+Stringify(typeof(object)));
       CHECK(false);
     }
   };  // Stringify
   const Last = arr => arr[arr.length-1];
   const Div = (a,b) => Math.floor(a/b);
   const Sub = (arr,indices) => Array.isArray(indices) ? indices.map(i=>Sub(arr,i)) : arr[indices]

   const Join = (sep,strings) => {
     let answer = "";
     for (const string of strings) {
       if (!EQ(answer.length, 0)) answer += sep;
       answer += string;
     }
     return answer;
   };

   const IsSubsetOf = (a,b) => {
     CHECK(a instanceof Set);
     CHECK(b instanceof Set);
     // TODO: is there an every() like there is for arrays?? return a.every(x=>b.has(x))
     for (const x of a) {
       if (!b.has(x)) {
         return false;
       }
     }
     return true;
   };

   // enumerate arrays of length k that are subsets of [0..n-1]
   const KSets = (n,k) => {
     CHECK(typeof(n) === 'number');
     CHECK(typeof(k) === 'number');
     if (k == 0) {
       return [[]];
     } else if (k == 1) {
       const answer = []
       for (let i = 0; i < n; ++i) answer.push([i]);
       return answer;
     } else if (k == 2) {
       const answer = []
       for (let i0 = 0; i0 < n; ++i0)
       for (let i1 = i0+1; i1 < n; ++i1)
         answer.push([i0,i1]);
       return answer;
     } else if (k == 3) {
       const answer = []
       for (let i0 = 0; i0 < n; ++i0)
       for (let i1 = i0+1; i1 < n; ++i1)
       for (let i2 = i1+1; i2 < n; ++i2)
         answer.push([i0,i1,i2]);
       return answer;
     } else if (k == 4) {
       const answer = []
       for (let i0 = 0; i0 < n; ++i0)
       for (let i1 = i0+1; i1 < n; ++i1)
       for (let i2 = i1+1; i2 < n; ++i2)
       for (let i3 = i2+1; i3 < n; ++i3)
         answer.push([i0,i1,i2,i3]);
       return answer;
     } else {
       // TODO: general
       CHECK(false);
     }
   };  // KSets

   // TODO: Need canonical way to express a prefill string.
   // All of the following should be accepted
   // (see http://hodoku.sourceforge.net/en/show_example.php?file=bf301&tech=Swordfish )
/*
Already accepted:
16.54..7...8..1.3..3.8.....7...5..696..9.2.57.............3..4........16...1645..

.----------------.------------.---------------.
| 1     6    29  | 5   4   3  | 289   7    28 |
| 29    7    8   | 6   29  1  | 4     3    5  |
| 4     3    5   | 8   29  7  | 6     29   1  |
:----------------+------------+---------------:
| 7     2    13  | 4   5   8  | 13    6    9  |
| 6     48   34  | 9   1   2  | 38    5    7  |
| 589   589  19  | 3   7   6  | 128   28   4  |
:----------------+------------+---------------:
| 2589  1    6   | 27  3   59 | 2789  4    28 |
| 3     459  249 | 27  8   59 | 279   1    6  |
| 289   89   7   | 1   6   4  | 5     289  3  |
'----------------'------------'---------------'
.----------------.------------.---------------.
| 1     6    29  | 5   4   3  | 289   7    28 |
| 29    7    8   | 6   29  1  | 4     3    5  |
| 4     3    5   | 8   29  7  | 6     29   1  |
:----------------+------------+---------------:
| 7     2    13  | 4   5   8  | 13    6    9  |
| 6     48   34  | 9   1   2  | 38    5    7  |
| 589   589  19  | 3   7   6  | 128   28   4  |
:----------------+------------+---------------:
| 2589  1    6   | 27  3   59 | 2789  4    28 |
| 3     459  249 | 27  8   59 | 279   1    6  |
| 289   89   7   | 1   6   4  | 5     289  3  |
'----------------'------------'---------------'
.----------------.------------.---------------.

| 1     6    29  | 5   4   3  | 289   7    28 |

| 29    7    8   | 6   29  1  | 4     3    5  |

| 4     3    5   | 8   29  7  | 6     29   1  |

:----------------+------------+---------------:

| 7     2    13  | 4   5   8  | 13    6    9  |

| 6     48   34  | 9   1   2  | 38    5    7  |

| 589   589  19  | 3   7   6  | 128   28   4  |

:----------------+------------+---------------:

| 2589  1    6   | 27  3   59 | 2789  4    28 |

| 3     459  249 | 27  8   59 | 279   1    6  |

| 289   89   7   | 1   6   4  | 5     289  3  |

'----------------'------------'---------------'
And from http://forum.enjoysudoku.com/a-pure-swordfish-collection-t5775.html
 2 . . | . 9 . | . . .
 . 6 . | . . 3 | 1 . .
 . . 1 | 2 . . | . 7 .
-------+-------+------
 . . 7 | . . . | . 2 .
 3 . . | . . . | . . 8
 . 8 . | . . . | 4 . .
-------+-------+------
 . 4 . | . . 8 | 6 . .
 . . 2 | 7 . . | . 1 .
 . . . | . 5 . | . . 4
*/



   // Output is typically too big, but put newlines before the <'s
   // and then grep something (I forget what)
   const ExtractPrefillStringFromNYTimesOuterHTML = (outerHTML) => {
     myconsole.log("        in ExtractPrefillStringFromNYTimesOuterHTML");
     // We use svg as a helper container,
     // because it has a getElementById method (unlike div,
     // for some strange reason).
     const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
     svg.innerHTML = outerHTML;
     myconsole.log("  svg = ",svg);

     const cells = svg.getElementsByClassName('su-cell');
     myconsole.log("          cells = ",cells);
     myconsole.log("          cells.length = ",cells.length);
     const n = Math.round(Math.sqrt(Math.sqrt(cells.length)));
     CHECK_EQ(n*n*n*n, cells.length);

     let answer = '';
     for (const cell of cells) {
       const label = cell.getAttribute("aria-label");
       myconsole.log("              label = "+Stringify(label));
       if (EQ(label, "empty")) {
         answer += "0";
       } else {
         CHECK_EQ(label.length, 1);
         answer += label;
       }
     }

     myconsole.log("        out ExtractPrefillStringFromNYTimesOuterHTML");
     return answer;
   };  // ExtractPrefillStringFromNYTimesOuterHTML

   // Output is typically too big, but put newlines before the <'s
   // and then `grep span` it.
   const ExtractPrefillStringFromLATimesOuterHTML = (outerHTML) => {
     myconsole.log("        in ExtractPrefillStringFromLATimesOuterHTML");
     // We use svg as a helper container,
     // because it has a getElementById method (unlike div,
     // for some strange reason).
     const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
     svg.innerHTML = outerHTML;
     myconsole.log("  svg = ",svg);

     const cells = svg.getElementsByClassName('letter-in-box');
     myconsole.log("          cells = ",cells);
     myconsole.log("          cells.length = ",cells.length);
     const n = Math.round(Math.sqrt(Math.sqrt(cells.length)));
     CHECK_EQ(n*n*n*n, cells.length);

     let answer = '';
     for (const cell of cells) {
       const value = cell.innerHTML.trim();
       if (EQ(value, '')) {
         answer += "0";
       } else {
         CHECK_EQ(value.length, 1);
         answer += value;
       }
     }

     myconsole.log("        out ExtractPrefillStringFromLATimesOuterHTML");
     return answer;
   };  // ExtractPrefillStringFromLATimesOuterHTML


   // Right-click on the `<div class="grid">`
   // or anything containing it, and choose Copy -> Outer HTML,
   // then save the string and feed it to this thing.
   const ExtractPrefillStringFromCrackingTheCrypticOuterHTML = (outerHTML) => {
     myconsole.log("        in ExtractPrefillStringFromCrackingTheCrypticOuterHTML");
     // We use svg as a helper container,
     // because it has a getElementById method (unlike div,
     // for some strange reason).
     const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
     svg.innerHTML = outerHTML;
     myconsole.log("  svg = ",svg);

     const cells = svg.getElementsByClassName('cell');
     myconsole.log("          cells = ",cells);
     myconsole.log("          cells.length = ",cells.length);
     const n = Math.round(Math.sqrt(Math.sqrt(cells.length)));
     CHECK_EQ(n*n*n*n, cells.length);

     // That was a good way of figuring out n,
     // but unfortunately the cells don't contain the information.
     // Look for text elements of class "cell-given" instead,
     // and we have to do presumptuous math to determine what they correspond to.

     const cell_givens = svg.getElementsByClassName('cell-given');
     myconsole.log("          cell_givens = ",cell_givens);
     myconsole.log("          cell_givens.length = ",cell_givens.length);
     CHECK_LE(cell_givens.length, cells.length);

     let answer = ''
     for (const cell_given of cell_givens) {
       const x = cell_given.getAttribute("x");
       const y = cell_given.getAttribute("y");
       myconsole.log("              x="+x+" y="+y);
       // For the 9x9, anyway:
       // x=32.96 -> col=0
       // x=224.96 -> col=3
       // y=35.2 -> row=0
       // y=99.2 -> row=1
       // y=163.2 -> row=3
       // ...
       // row=0 col=0:  y=35.2 x=32.96
       const col = Math.round(x-32.96)/64;
       const row = Math.round(y-35.2)/64;
       CHECK_EQ(Math.round(col), col);
       CHECK_EQ(Math.round(row), row);
       const innerHTML = cell_given.innerHTML;
       myconsole.log("                  col="+col+" row="+row+" innerHTML="+Stringify(innerHTML));
       CHECK_EQ(innerHTML.length, 1);
       const index = row*n*n + col;
       while (answer.length < index) answer += '0';
       answer += innerHTML;
     }
     while (answer.length < n*n*n*n) answer += '0';

     myconsole.log("        out ExtractPrefillStringFromCrackingTheCrypticOuterHTML");
     return answer;
   };  // ExtractPrefillStringFromCrackingTheCrypticOuterHTML

   // Right-click on the `<div id="grilleJeu">`
   // or anything containing it, and choose Copy -> Outer HTML,
   // then save the string and feed it to this thing.
   const ExtractPrefillStringFrom1SudokoOuterHTML = (outerHTML) => {
     // We use svg as a helper container,
     // because it has a getElementById method (unlike div,
     // for some strange reason).
     const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
     svg.innerHTML = outerHTML;
     myconsole.log("  svg = ",svg);
     let answer = ''
     // or, could just grab everything with class "c", I think.
     for (let i = 0; ; i++) {
       const id = "c_"+i;
       const div = svg.getElementById(id);
       if (div === null) {
         break;
       }
       //myconsole.log("      div = ",div);
       //myconsole.log('      div.getAttribute("v") = ',div.getAttribute("v"));
       const v = div.getAttribute("v");
       if (v != null) {
         answer += v;
       } else {
         answer += '0';
       }
     }
     return answer;
   };  // ExtractPrefillStringFrom1SudokoOuterHTML

   const PrefillString2Prefill = prefill_string => {
      const prefill_string_digits_only = prefill_string.replace(/[^0-9a-zA-Z]/g, '');
      myconsole.log("  prefill_string_digits_only = ",prefill_string_digits_only);

      const n = Math.round(Math.sqrt(Math.sqrt(prefill_string_digits_only.length)));
      myconsole.log("  n = ",n);
      CHECK_EQ(prefill_string_digits_only.length, n*n*n*n);
      const prefill = [];
      for (let i = 0; i < n*n*n*n; ++i) {
        prefill.push(name2intvalue(prefill_string_digits_only[i]));
      }
      myconsole.log("  prefill = ",prefill);
      return [n,prefill];
   };  // PrefillString2Prefill

   if (false) {  // XXX this doesn't work anyu more because myconsole not initialized yet
     const sample = '<div id="grilleJeu"> <div id="c_0" class="c fixe" l="1" c="1" r="1" v="3"><p>3</p></div><div id="c_1" class="c" l="1" c="2" r="1"></div><div id="c_2" class="c" l="1" c="3" r="2"></div><div id="c_3" class="c fixe" l="1" c="4" r="2" v="2"><p>2</p></div><div id="c_4" class="c" l="2" c="1" r="1"></div><div id="c_5" class="c" l="2" c="2" r="1"></div><div id="c_6" class="c fixe" l="2" c="3" r="2" v="3"><p>3</p></div><div id="c_7" class="c" l="2" c="4" r="2"></div><div id="c_8" class="c" l="3" c="1" r="3"></div><div id="c_9" class="c fixe" l="3" c="2" r="3" v="4"><p>4</p></div><div id="c_10" class="c" l="3" c="3" r="4"></div><div id="c_11" class="c" l="3" c="4" r="4"></div><div id="c_12" class="c fixe" l="4" c="1" r="3" v="1"><p>1</p></div><div id="c_13" class="c" l="4" c="2" r="3"></div><div id="c_14" class="c" l="4" c="3" r="4"></div><div id="c_15" class="c" l="4" c="4" r="4"></div>            </div>';

     const prefill_string = ExtractPrefillStringFrom1SudokoOuterHTML(sample);
     myconsole.log("  prefill_string = ",prefill_string);
     /*
     3 . . 2
     . . 3 .
     . 4 . .
     1 . . .
     <div id="grilleJeu">
       <div id="c_0" class="c fixe" l="1" c="1" r="1" v="3"><p>3</p></div>
       <div id="c_1" class="c" l="1" c="2" r="1"></div>
       <div id="c_2" class="c" l="1" c="3" r="2"></div>
       <div id="c_3" class="c fixe" l="1" c="4" r="2" v="2"><p>2</p></div>

       <div id="c_4" class="c" l="2" c="1" r="1"></div>
       <div id="c_5" class="c" l="2" c="2" r="1"></div>
       <div id="c_6" class="c fixe" l="2" c="3" r="2" v="3"><p>3</p></div>
       <div id="c_7" class="c" l="2" c="4" r="2"></div>

       <div id="c_8" class="c" l="3" c="1" r="3"></div>
       <div id="c_9" class="c fixe" l="3" c="2" r="3" v="4"><p>4</p></div>
       <div id="c_10" class="c" l="3" c="3" r="4"></div>
       <div id="c_11" class="c" l="3" c="4" r="4"></div>

       <div id="c_12" class="c fixe" l="4" c="1" r="3" v="1"><p>1</p></div>
       <div id="c_13" class="c" l="4" c="2" r="3"></div>
       <div id="c_14" class="c" l="4" c="3" r="4"></div>
       <div id="c_15" class="c" l="4" c="4" r="4"></div>
     </div>'
     */
   }

   // e.g. [12,14,21] => "r1c35,r2c3"
   // TODO: produces r13c9,r3c8, should be r1c9,r3c89
   const cellset2terse = (n,cells) => {
     //return Stringify(cells);
     const groups = [];
     for (const cell of [...cells].sort((a,b)=>a-b)) {
       let pushed = false;
       for (const group of [...groups].reverse()) {  // search backwards, so we get r1c9,r3c89 instead of r13c9,r3c8
         // if group all in same row or col as cell, add to group
         if (group.every(groupcell => EQ(Div(groupcell,n*n), Div(cell,n*n))) ||
             group.every(groupcell => EQ(groupcell%(n*n), cell%(n*n)))) {
           group.push(cell);
           pushed = true;
           break;
         }
       }
       if (!pushed) groups.push([cell]);
     }
     //return Stringify(groups);
     const group_strings = [];
     for (const group of groups) {
       group_strings.push('r'+Join('',new Set(group.map(cell=>''+(Div(cell,n*n)+1))))+
                          'c'+Join('',new Set(group.map(cell=>''+(cell%(n*n)+1)))));
     }
     return Join(',', group_strings);
   };  // cellset2terse

   console.log("in script");

   const myconsole = MyConsole();
   myconsole.attachToElement(window.myconsole, window.myconsolelinecount);

   myconsole.doWhileBuffered(()=>{
     try {
       myconsole.log("  window.location = ",window.location);
       myconsole.log("  window.location.href = ",window.location.href);

       let n = 3;  // standard puzzle: 3x3x3x3

       let prefill = undefined;

       if (true) {

         // Whoa, this one gets *no* progress other than the initial naked single projection (although I haven't implemented swordfish yet)
         // https://www.telegraph.co.uk/news/science/science-news/9359579/Worlds-hardest-sudoku-can-you-crack-it.html
         //const url_param_prefill = '800000000.003600000.070090200.050007000.000045700.000100030.001000068.008500010.090000400';
         //  file:///home/donhatch/gitrepos/sudokusolve/sudokusolve.html?prefill=800000000.003600000.070090200.050007000.000045700.000100030.001000068.008500010.090000400

         //const url_param_prefill = '003020600.900305001.001806400.008102900.700000008.006708200.002609500.800203009.005010300';
         //
         // An "easy" 16x16 puzzle from https://1sudoku.com/sudoku-variants/super-sudoku-16x16
         //const url_param_prefill = ('_EG3_F9__24_da7_' + 'DB_6A______CE_F2' + '_28_74e1db5a_6G_' + '__a____dg____B__' + '3______79______g' + '_A61_GC__8F_42D_' + '_854________6EA_' + '____BA_45_6E____' + '____29_84_c7____' + '_518________2g9_' + '_3fd_cg__51_87e_' + '4______3e______5' + '__d____23____5__' + '_62_g34EFAD5_C1_' + '_c35_8F__72_gd6_' + 'a1_F5______87_23').replace(/_/g, '0').toLowerCase();

         //const url_param_prefill = '1000.0200.0030.0004';  // unsolvable
         //const url_param_prefill = '1300.0200.0030.0004';  // solvable
         //const url_param_prefill = '1300.0200.0030.0000';  // unsolvable
         //const url_param_prefill = '1300.0000.0032.0000';  // solvable

         let url_param_prefill = new URL(window.location.href).searchParams.get("prefill");

         //const url_param_prefill = ExtractPrefillStringFrom1SudokoOuterHTML('<div id="grilleJeu"> <div id="c_0" class="c fixe" l="1" c="1" r="1" v="A"><p>3</p></div><div id="c_1" class="c" l="1" c="2" r="1"></div><div id="c_2" class="c" l="1" c="3" r="2"></div><div id="c_3" class="c fixe" l="1" c="4" r="2" v="2"><p>2</p></div><div id="c_4" class="c" l="2" c="1" r="1"></div><div id="c_5" class="c" l="2" c="2" r="1"></div><div id="c_6" class="c fixe" l="2" c="3" r="2" v="3"><p>3</p></div><div id="c_7" class="c" l="2" c="4" r="2"></div><div id="c_8" class="c" l="3" c="1" r="3"></div><div id="c_9" class="c fixe" l="3" c="2" r="3" v="4"><p>4</p></div><div id="c_10" class="c" l="3" c="3" r="4"></div><div id="c_11" class="c" l="3" c="4" r="4"></div><div id="c_12" class="c fixe" l="4" c="1" r="3" v="1"><p>1</p></div><div id="c_13" class="c" l="4" c="2" r="3"></div><div id="c_14" class="c" l="4" c="3" r="4"></div><div id="c_15" class="c" l="4" c="4" r="4"></div>            </div>');

         myconsole.log("  url_param_prefill = ",url_param_prefill);

         if (url_param_prefill[0] == 'p') {
           // Get it out of file_contents
           const found = url_param_prefill.match(/^.*[^0-9]([0-9]+)$/);
           myconsole.log("  found = ",found);
           const puzzle_number = parseInt(found[1]);
           myconsole.log("  puzzle_number = ",puzzle_number);
           const puzzle_numeral = ''+((puzzle_number-puzzle_number%10)/10)+(puzzle_number%10);

           const what_to_look_for = "Grid "+puzzle_numeral+"\n";
           myconsole.log("  what_to_look_for = ",what_to_look_for);
           const index = file_contents.indexOf(what_to_look_for);
           myconsole.log("  index = ",index);
           CHECK_GE(index, 0);
           url_param_prefill = ''
           for (let i = index + what_to_look_for.length; i < file_contents.length && url_param_prefill.length < 81; ++i) {
             if (file_contents[i] >= '0' && file_contents[i] <= '9') {
               url_param_prefill += file_contents[i];
             }
           }
           myconsole.log("  url_param_prefill = ",url_param_prefill);

           if (true) {  // XXX need to do this without appending to document.body.innerHTML!!
             // Make "prev" and "next" links
             if (puzzle_number > 1) {
               const scratch = new URL(window.location.href);
               scratch.searchParams.set("prefill", "p"+(puzzle_number-1));
               window.prevlink.innerHTML = '<a href="'+scratch.href+'">prev</a>';
             }
             if (puzzle_number < 50) {
               const scratch = new URL(window.location.href);
               scratch.searchParams.set("prefill", "p"+(puzzle_number+1));
               window.nextlink.innerHTML = '<a href="'+scratch.href+'">next</a>';
             }
           }
         }
        [n,prefill] = PrefillString2Prefill(url_param_prefill);

       } else {
         prefill = [];
         for (let i = 0; i < n*n*n*n; ++i) {
           prefill.push(0);
         }
       }


       let digitToHighlight = null;


       const PopulateIt = prefill => {
         let the_table = document.getElementsByClassName("toplevel_table");
         the_table.innerHTML = '';  // clear it, for starters

         myconsole.log("  the_table = ",the_table);
         CHECK_EQ(the_table.length, 1);
         the_table = the_table[0];
         myconsole.log("  the_table = ",the_table);

         let table_inner_html = ''
         for (let i = 0; i < n*n; ++i) {
           const after_divider_maybe = i!=0 && i%n==0 ? " after_divider" : "";
           table_inner_html += '<tr class="toplevel_row'+after_divider_maybe+'">'
           for (let j = 0; j < n*n; ++j) {
             const after_divider_maybe = j!=0 && j%n==0 ? " after_divider" : "";
             const prefilled_maybe = prefill[i*n*n+j] != 0 ? " prefilled" : "";
             table_inner_html += ' <td class="cell'+after_divider_maybe+prefilled_maybe+'" onmouseover="mouseOverCell(event,'+(i*n*n+j)+');" onmouseout="mouseOutCell(event,'+(i*n*n+j)+')">';
           }
         }

         the_table.innerHTML = table_inner_html;

         const cells = document.getElementsByClassName("cell");
         CHECK_EQ(cells.length, n*n*n*n);


         // State will be a list of candidates for each cell.
         const state = [];
         for (let i = 0; i < n*n*n*n; ++i) {
           if (EQ(prefill[i], 0)) {
             state.push(range(1,n*n+1));
           } else {
             state.push([prefill[i]]);
           }
         }

         const cell2row = [];
         const cell2col = [];
         const cell2block = [];
         const cell2houses = [];
         const house2cells = [];
         const houseNames = [];
         const row2cells = [];
         const col2cells = [];
         const block2cells = [];
         for (let i = 0; i < n*n; ++i) {
           row2cells.push([]);
           col2cells.push([]);
           block2cells.push([]);
         }
         for (let house = 0; house < 3*n*n; ++house) {
           house2cells.push([]);
           houseNames.push(house < n*n ? "Row "+house :
                           house < 2*(n*n) ? "Col "+(house-n*n)
                                           : "Block "+(house-2*(n*n)));
         }
         myconsole.log("  n = "+n);
         for (let cell = 0; cell < n*n*n*n; ++cell) {
           //myconsole.log("      cell = "+cell);
           const row = Math.floor(cell / (n*n));
           const col = cell % (n*n);
           const blockrow = Div(Div(cell,n*n), n);
           const blockcol = Div(cell%(n*n), n);
           const block = blockrow*n + blockcol;
           const rowhouse = row;
           const colhouse = n*n + col;
           const blockhouse = 2*(n*n) + block;
           //myconsole.log("          row = "+row);
           //myconsole.log("          col = "+col);
           //myconsole.log("          blockrow = "+blockrow);
           //myconsole.log("          blockcol = "+blockcol);
           //myconsole.log("          block = "+block);
           //myconsole.log("          blockhouse = "+blockhouse);
           cell2row.push(row);
           cell2col.push(col);
           cell2block.push(block);
           cell2houses.push([rowhouse,colhouse,blockhouse]);
           house2cells[rowhouse].push(cell);
           house2cells[colhouse].push(cell);
           house2cells[blockhouse].push(cell);
           row2cells[row].push(cell);
           col2cells[col].push(cell);
           block2cells[block].push(cell);
         }

         myconsole.log("  initial state = "+Stringify(state));
         return [n,state,cells,[],[],
                 cell2row,cell2col,cell2block,cell2houses,house2cells,houseNames,
                 row2cells,col2cells,block2cells];
       };  // PopulateIt

       let [state,cells,undoStack,redoStack,
            cell2row,cell2col,cell2block,cell2houses,house2cells,houseNames,
            row2cells,col2cells,block2cells] = [undefined];
       [n, state,cells,undoStack,redoStack,
        cell2row,cell2col,cell2block,cell2houses,house2cells,houseNames,
        row2cells,col2cells,block2cells] = PopulateIt(prefill);
       myconsole.log("state = "+Stringify(state));

       // Propagate singles to eliminate candidates.
       const doPropagateSingles = (n, oldState) => {
         myconsole.log("      in doPropagateSingles(n="+n+", state)");
         const newState = deepCopy(oldState);
         for (let i = 0; i < n*n; ++i) {
           for (let j = 0; j < n*n; ++j) {
             if (oldState[i*(n*n)+j].length == 1) {
               // same row
               //myconsole.log("      state["+i+"]["+j+"] is a singleton "+oldState[i*(n*n)+j][0]+"; lasering");
               for (let k = 0; k < n*n; ++k) {
                 if (k != j) {
                   removeIf(newState[i*(n*n)+k], x => x===oldState[i*(n*n)+j][0]);
                 }
               }
               for (let k = 0; k < n*n; ++k) {
                 if (k != i) {
                   removeIf(newState[k*(n*n)+j], x => x===oldState[i*(n*n)+j][0]);
                 }
               }
               for (let ii = 0; ii < n; ++ii) {
                 for (let jj = 0; jj < n; ++jj) {
                   if (ii != i%n || jj != j%n) {
                     removeIf(newState[(i-i%n+ii)*(n*n)+(j-j%n+jj)], x=>x===oldState[i*(n*n)+j][0]);
                   }
                 }
               }
             }
           }
         }
         myconsole.log("      out doPropagateSingles(n="+n+", state)");
         return newState;
       };  // doPropagateSingles

       const doHiddenSingles = (n, oldState) => {
         const verbose_level = 1;
         if (verbose_level >= 1) myconsole.log("        in doHiddenSingles(n="+n+", oldState)");
         if (verbose_level >= 2) myconsole.log("          oldState = "+Stringify(oldState));
         const newState = deepCopy(oldState);
         // For each digit and house (i.e. row, column, or block),
         // if there's only one place the digit can go
         // in that house, then put it there
         // (i.e. remove all other candidates in that cell).

         for (let digit = 1; digit <= n*n; ++digit) {
           if (verbose_level >= 2) myconsole.log("              digit = "+digit);

           for (let ihouse = 0; ihouse < house2cells.length; ++ihouse) {
             const candidatePositionsInHouse = [];
             for (let iinhouse = 0; iinhouse < house2cells[ihouse].length; ++iinhouse) {
               const cell = house2cells[ihouse][iinhouse];
               if (oldState[cell].includes(digit)) {
                 candidatePositionsInHouse.push(iinhouse);
               }
             }
             if (candidatePositionsInHouse.length === 1) {
               if (verbose_level >= 2) myconsole.log("                  digit "+intvalue2name(digit)+" can go in only position "+candidatePositionsInHouse[0]+":"+house2cells[ihouse][candidatePositionsInHouse[0]]+" in house "+ihouse+" = "+Stringify(house2cells[ihouse]));
               const cell = house2cells[ihouse][candidatePositionsInHouse[0]];
               newState[cell].length = 1;
               newState[cell][0] = digit;
             }
           }
         }

         if (verbose_level >= 1) myconsole.log("        out doHiddenSingles(n="+n+", oldState)");
         return newState;
       };  // doHiddenSingles


       let XXXmax_ever_ksets = -1;
       const TryToExtractOneFish = (digit,
                                    fish_size,
                                    base_housetype,
                                    covering_housetype,
                                    remaining_basehouses,
                                    remaining_coveringhouses,
                                    state) => {
         const verbose_level = 0;
         if (verbose_level >= 1) myconsole.log("                        in TryToExtractOneFish(digit="+digit+", fish_size="+fish_size+", base_housetype="+base_housetype+" covering_housetype="+covering_housetype+" remaining_basehouses="+Stringify(remaining_basehouses)+" remaining_coveringhouses="+Stringify(remaining_coveringhouses)+")");
         const n_remaining_rowscols = remaining_basehouses.length;
         CHECK_EQ(n_remaining_rowscols, remaining_coveringhouses.length);

         // CBB: probably very inefficient.  Well, worst case for n=3 is k=4, which is
         // (9 choose 4)=126 subsets.
         const ksets = KSets(n_remaining_rowscols, fish_size);
         if (verbose_level >= 1) myconsole.log("                          iterating over "+ksets.length+" "+fish_size+"-sets of "+n_remaining_rowscols);
         XXXmax_ever_ksets = Math.max(XXXmax_ever_ksets, ksets.length);
         const base_house2cell = base_housetype===0 ? row2cells : base_housetype===1 ? col2cells : blocks2cells;

         for (const kset of ksets) {
           if (verbose_level >= 2) myconsole.log("                              kset = "+Stringify(kset));
           const base_houses = Sub(remaining_basehouses, kset);
           const covering_houses = [];
           for (const covering_house of remaining_coveringhouses) {
             for (const base_house of base_houses) {
               const cell = base_house2cell[base_house][covering_house];
               if (state[cell].includes(digit)) {
                 covering_houses.push(covering_house);
                 break;  // done with this covering house
               }
             }
             if (covering_houses.length > fish_size) {
               break;  // no good
             }
           }
           CHECK_GE(covering_houses.length, fish_size);
           if (covering_houses.length == fish_size) {
             // found a fish!!!!
             if (verbose_level >= 1) myconsole.log("                                  found a fish! base_houses="+Stringify(base_houses)+" covering_houses="+Stringify(covering_houses));
             const answer = [base_houses,covering_houses];
             if (verbose_level >= 1) myconsole.log("                        out TryToExtractOneFish(digit="+digit+", fish_size="+fish_size+", base_housetype="+base_housetype+" covering_housetype="+covering_housetype+" remaining_basehouses="+Stringify(remaining_basehouses)+" remaining_coveringhouses="+Stringify(remaining_coveringhouses)+"), returning "+Stringify(answer));
             return answer;
           }
         }

         if (verbose_level >= 1) myconsole.log("                        out TryToExtractOneFish(digit="+digit+", fish_size="+fish_size+", base_housetype="+base_housetype+" covering_housetype="+covering_housetype+" remaining_basehouses="+Stringify(remaining_basehouses)+" remaining_coveringhouses="+Stringify(remaining_coveringhouses)+"), returning null at bottom");
         return null;
       };  // TryToExtractOneFish

       // Note that a k-row k-column fish (k base rows, k covering columns) is equivalent to:
       // if a given intersection of k rows with n-k columns is empty,
       // then the complementary intersection of n-k rows with n-k columns
       // must also be also empty.
       // This leads to the concept of a row-column fish decomposition.
       // The decomposition is a partitioning of the original n rows,
       // where each partition of k rows has a corresponding cover of n-k columns,
       // such that either the intersection of the k rows and complementary (n-k) columns is empty
       // or the intersection of the complementary (n-k) rows and k columns is empty,
       // and so the other can be made empty.

       const UncachedRowColumnFishDecompose = (digit, max_fish_size, n, state) => {
         const verbose_level = 1;
         if (verbose_level >= 1) myconsole.log("                in UncachedRowColumnFishDecompose(digit="+digit+", max_fish_size="+max_fish_size+", n="+n+", state)");

         let answer = [[range(n*n),range(n*n)]];  // one partition containing all n rows and n columns

         let count = 0;
         for (let fish_size = 1; fish_size <= max_fish_size && fish_size*2 <= Last(answer)[0].length; ++fish_size) {
           if (verbose_level >= 2) myconsole.log("                      fish_size = "+fish_size);
           if (verbose_level >= 2) myconsole.log("                          answer so far = "+Stringify(answer));
           while (true) {
             CHECK_LE(++count, 100);

             let fish = TryToExtractOneFish(digit, fish_size,
                                            0, 1,
                                            /*remaining_rows=*/Last(answer)[0],
                                            /*remaining_cols=*/Last(answer)[1],
                                            state);
             if (fish === null) {
               fish = TryToExtractOneFish(digit, fish_size,
                                          1, 0,
                                          /*remaining_cols=*/Last(answer)[1],
                                          /*remaining_rows=*/Last(answer)[0],
                                          state);
               if (fish !== null) { fish = [fish[1],fish[0]]; }
             }
             if (fish === null) {
               break;  // on to the next size
             }
             const [fish_rows,fish_cols] = fish;
             let [remaining_rows,remaining_cols] = answer.pop();
             answer.push([fish_rows,fish_cols]);
             remaining_rows = SortedArrayMinus(remaining_rows, fish_rows);
             remaining_cols = SortedArrayMinus(remaining_cols, fish_cols);
             answer.push([remaining_rows,remaining_cols]);
           }
         };
         if (verbose_level >= 1) myconsole.log("                out UncachedRowColumnFishDecompose(digit="+digit+", max_fish_size="+max_fish_size+", n="+n+", state), returning "+Stringify(answer));
         return answer;
       };  // UncachedRowColumnFishDecompose

       // This is called a LOT on the same state.  maybe cache?  ok lets's try...
       // CBB: don't grow forever, make this an LRU queue or something, or explicitly clear it.  Oh hey, I think maps keep track of insertion order, so just remove and re-insert to refresh!
       let fish_cache = new Map();
       let fish_cache_max_size = 1000*1000;
       let cacheMisses = 0;
       let cacheHits = 0;

       const CachedRowColumnFishDecompose = (digit, max_fish_size, n, state) => {
         const verbose_level = 1;
         if (verbose_level >= 1) myconsole.log("            in CachedRowColumnFishDecompose(digit="+digit+", max_fish_size="+max_fish_size+", n="+n+", state)");

         if (false) {
           // bypass cache
           const answer = UncachedRowColumnFishDecompose(digit, max_fish_size, n, state);
           if (verbose_level >= 1) myconsole.log("            out RowColumnFishDecompose(digit="+digit+", max_fish_size="+max_fish_size+", n="+n+", state), returning "+Stringify(answer)+" (bypassing cache)");
           return answer;
         }

         const key = Stringify([digit, max_fish_size, n, state]);

         if (fish_cache.has(key)) {
           ++cacheHits;
           const value = fish_cache.get(key);
           const answer = deepCopy(value);  // CBB: is the deepCopy necessary?  I don't know

           // remove and re-insert, so that we have a record of freshness.
           fish_cache.delete(key);
           fish_cache.set(key, value);

           if (verbose_level >= 1) myconsole.log("            out RowColumnFishDecompose(digit="+digit+", max_fish_size="+max_fish_size+", n="+n+", state), returning "+Stringify(answer)+" (cache hit)");
           return answer;
         } else {
           ++cacheMisses;
           const answer = UncachedRowColumnFishDecompose(digit, max_fish_size, n, state);
           // CBB: probably shouldn't need all these deepCopies, but I don't have a clear handle on what my immutability policy is
           fish_cache.set(key, deepCopy(answer));  // CBB: is the deepCopy necessary? I don't know
           if (verbose_level >= 1) myconsole.log("            out RowColumnFishDecompose(digit="+digit+", max_fish_size="+max_fish_size+", n="+n+", state), returning "+Stringify(answer)+" (cache miss)");
           return answer;
         }
       };  // CachedRowColumnFishDecompose


       const doFishes = (min_fish_size, max_fish_size, n, oldState) => {
         const verbose_level = 1;
         if (verbose_level >= 1) myconsole.log("        in doFishes(max_fish_size="+max_fish_size+", n="+n+", state)");
         CHECK_EQ(typeof(min_fish_size), 'number');
         CHECK_EQ(typeof(max_fish_size), 'number');
         CHECK_EQ(typeof(n), 'number');
         CHECK(Array.isArray(oldState));
         CHECK(Array.isArray(oldState[0]));
         CHECK(!Array.isArray(oldState[0][0]));
         // First of all, make sure there's at least one copy of each digit
         // in each row and each column.  If not, everything will go insane.
         for (let digit = 1; digit <= n*n; ++digit) {
           for (let house = 0; house < 2*n*n; ++house) {  // i.e. rows and columns
             let num_in_house = 0;
             for (let cell of house2cells[house]) {
               if (oldState[cell].includes(digit)) num_in_house++;
             }
             if (num_in_house === 0) {
               if (verbose_level >= 1) myconsole.log("        out doFishes(max_fish_size="+max_fish_size+", n="+n+", state), state is illegal since no instances of digit "+digit+" in house "+houseNames[house]);
             }
           }
         }

         if (verbose_level >= 1) myconsole.log("          oldState = "+Stringify(oldState));
         const newState = deepCopy(oldState);

         for (let digit = 1; digit <= n*n; ++digit) {
           if (verbose_level >= 1) myconsole.log("          digit = "+digit);
           const decomposition = CachedRowColumnFishDecompose(digit, max_fish_size, n, oldState);

           if (false) {  // assumes we want to use all the parts, which isn't true
             // Simplest way to do this that I can think of is to clear the digit
             // from all cells that aren't in any of the fishes.
             const cells_to_clear = new Set(range(n*n*n*n));
             for (const [fish_rows,fish_cols] of decomposition) {
               for (const row of fish_rows) {
                 for (const col of fish_cols) {
                   cells_to_clear.delete(row*(n*n) + col);
                 }
               }
             }
             for (const cell of cells_to_clear) {
               removeIf(newState[cell], x => x===digit);
             }
           } else {
             for (const [fish_rows,fish_cols] of decomposition) {
               if (fish_rows.length >= min_fish_size && fish_rows.length <= max_fish_size) {
                 const non_fish_rows = new Set(range(n*n));
                 for (const fish_row of fish_rows) non_fish_rows.delete(fish_row);
                 const non_fish_cols = new Set(range(n*n));
                 for (const fish_col of fish_cols) non_fish_cols.delete(fish_col);

                 let might_be_a_row_fish = true;
                 let might_be_a_col_fish = true;
                 for (const row of fish_rows) {
                   for (const col of non_fish_cols) {
                     if (oldState[row*(n*n)+col].includes(digit)) {
                       might_be_a_row_fish = false;
                       break;
                     }
                   }
                 }
                 for (const row of non_fish_rows) {
                   for (const col of fish_cols) {
                     if (oldState[row*(n*n)+col].includes(digit)) {
                       might_be_a_col_fish = false;
                       break;
                     }
                   }
                 }
                 if (might_be_a_row_fish && !might_be_a_col_fish) {
                   for (const row of non_fish_rows) {
                     for (const col of fish_cols) {
                       removeIf(newState[row*(n*n)+col], x => x===digit);
                     }
                   }
                 } else if (might_be_a_col_fish && !might_be_a_row_fish) {
                   for (const row of non_fish_rows) {
                     for (const col of fish_cols) {
                       removeIf(newState[row*(n*n)+col], x => x===digit);
                     }
                   }
                 }
               }
             }
           }
         }
         if (verbose_level >= 1) myconsole.log("              XXXmax_ever_ksets = "+XXXmax_ever_ksets);
         XXXmax_ever_ksets = -1;
         if (verbose_level >= 1) myconsole.log("              cacheHits = "+cacheHits);
         if (verbose_level >= 1) myconsole.log("              cacheMisses = "+cacheMisses);
         if (verbose_level >= 1) myconsole.log("              fish_cache.size = "+fish_cache.size);
         if (verbose_level >= 1) myconsole.log("        out doFishes(max_fish_size="+max_fish_size+", n="+n+", state)");
         return newState;
      };  // doFishes

       const doNakedTuples = (tuplicity, n, oldState) => {
         const verbose_level = 1;
         if (verbose_level >= 1) myconsole.log("        in doNakedTuples(tuplicity="+tuplicity+", n="+n+", state)");
         const newState = deepCopy(oldState);

         // What is a naked pair?  It's when two cells in a house
         // have the exact same two candidates.  In this case we can eliminate
         // those two candidates from the rest of the house.

         // What is a naked triple?  It's when three cells in a house
         // have only three candidates among them, although it may be that only
         // two of them occur at a time.  E.g.
         //   123 123 12
         //   12 13 23
         // In that case we can eliminate these three candidates from
         // the rest of the house.

         for (let ihouse = 0; ihouse < house2cells.length; ++ihouse) {
           if (verbose_level >= 2) myconsole.log("            ihouse = "+ihouse+" = "+Stringify(house2cells[ihouse]));

           const iindicesOfNonSingles = [];
           for (let iinhouse = 0; iinhouse < n*n; ++iinhouse) {
             const cell = house2cells[ihouse][iinhouse];
             if (oldState[cell].length >= 2) {
              iindicesOfNonSingles.push(iinhouse);
             }
           }
           // CBB: probably very inefficient, especially when no naked singles
           // in the house
           const ksets = KSets(iindicesOfNonSingles.length, tuplicity);
           for (const kset of ksets) {
             const union = new Set();
             for (const i of kset) {
               const iinhouse = iindicesOfNonSingles[i];
               const cell = house2cells[ihouse][iinhouse];
               for (const digit of oldState[cell]) {
                 union.add(digit);
               }
             }
             if (union.size == tuplicity) {
               if (verbose_level >= 2) myconsole.log("                    found naked "+tuplicity+"-tuple "+Stringify(union)+" in house "+houseNames[ihouse]+" non-single positions "+Stringify(kset));
               // remove the digits in the union from the rest of this house.
               const removed_list = [];
               for (let i = 0; i < iindicesOfNonSingles.length; ++i) {
                 if (!kset.includes(i)) {
                   const iinhouse = iindicesOfNonSingles[i];
                   const cell = house2cells[ihouse][iinhouse];

                   for (const x of oldState[cell]) {
                     if (union.has(x)) {
                       removed_list.push(cell);
                       break;
                     }
                   }
                   removeIf(newState[cell], x => union.has(x));
                 }
               }
               if (verbose_level >= 2) myconsole.log("                        removed_list = "+Stringify(removed_list));
               if (verbose_level >= 1) myconsole.log("                        "+houseNames[ihouse]+": "+cellset2terse(n,kset.map(i=>house2cells[ihouse][iindicesOfNonSingles[i]]))+" => "+cellset2terse(n,removed_list)+"<>"+Join('',union));
             }
           }

          }
         if (verbose_level >= 1) myconsole.log("        out doNakedTuples(tuplicity="+tuplicity+", n="+n+", state)");
         return newState;
       };  // doNakedTuples

       const doHiddenTuples = (tuplicity, n, oldState) => {
         const verbose_level = 1;
         if (verbose_level >= 1) myconsole.log("        in doHiddenTuples(tuplicity="+tuplicity+", n="+n+", state)");
         const newState = deepCopy(oldState);
         for (let ihouse = 0; ihouse < house2cells.length; ++ihouse) {
           if (verbose_level >= 3) myconsole.log("            ihouse = "+ihouse+" = "+Stringify(house2cells[ihouse]));

           // What exactly is a hidden pair?
           // It's a pair of digits such that each of them occurs only twice
           // in the house, in the same place.

           // What exactly is a hidden triple?
           // Well, it's 3 different digits
           // whose union spans only 3 different cells in this house.
           // (and none of them should be naked singles)

           const definitelyUninterestingDigits = new Set();
           for (let cell of house2cells[ihouse]) {
             const oldStateCell = oldState[cell];
             if (oldStateCell.length == 1) {
               definitelyUninterestingDigits.add(oldStateCell[0]);
             }
           }

           // CBB: should be array indexed by digit, but the 1-basing makes it awkward
           const digit2indicesInHouse = new Map();
           for (let digit = 1; digit <= n*n; ++digit) {
             if (definitelyUninterestingDigits.has(digit)) continue;
             digit2indicesInHouse.set(digit, []);
           }
           for (let iinhouse = 0; iinhouse < n*n; ++iinhouse) {
             const cell = house2cells[ihouse][iinhouse];
             for (const digit of oldState[cell]) {
               if (definitelyUninterestingDigits.has(digit)) continue;
               digit2indicesInHouse.get(digit).push(iinhouse);
             }
           }

           const interesting_digits = [];
           for (let digit = 1; digit <= n*n; ++digit) {
             if (definitelyUninterestingDigits.has(digit)) continue;
             if (digit2indicesInHouse.get(digit).length >= 2 &&
                 digit2indicesInHouse.get(digit).length <= tuplicity) {
               interesting_digits.push(digit);
             }
           }
           if (verbose_level >= 3) myconsole.log("                interesting_digits = "+Stringify(interesting_digits));

           const ksets = KSets(interesting_digits.length, tuplicity);
           if (verbose_level >= 2) myconsole.log("                ksets = "+Stringify(ksets));;
           for (const kset of ksets) {
             const tuple = Sub(interesting_digits, kset);
             if (verbose_level >= 3) myconsole.log("                considering tuple of digits "+Stringify(tuple));
             const union = new Set();
             for (const digit of tuple) {
               for (const iinhouse of digit2indicesInHouse.get(digit)) {
                 union.add(iinhouse);
               }
             }
             if (verbose_level >= 3) myconsole.log("                    union = "+Stringify(union));
             if (union.size == tuplicity) {
               if (verbose_level >= 2) myconsole.log("                    found hidden (or maybe already naked) "+tuplicity+"-tuple "+Stringify(tuple)+" in house "+ihouse+" positions "+Stringify(union));
               // Make this tuple naked, by removing everything except
               // the specific digits.
               for (const iinhouse of union) {
                 const cell = house2cells[ihouse][iinhouse];
                 removeIf(newState[cell], x => !tuple.includes(x));
               }
             }
           }
         }
         if (verbose_level >= 1) myconsole.log("        out doHiddenTuples(tuplicity="+tuplicity+", n="+n+", newState)");
         return newState;
       };  // doHiddenTuples

       const doOmissions = (n, oldState) => {
         const verbose_level = 1;
         if (verbose_level >= 1) myconsole.log("        in doOmissions(n="+n+", state)");
         const newState = deepCopy(oldState);

         // When a given digit's occurrances (candidacies) in house A
         // is limited to an intersecting house B,
         // then that digit can be eliminated from the rest of house B.
         // (one of A or B will be a block, the other will be a row or
         // column)

         for (let digit = 1; digit <= n*n; ++digit) {
           if (verbose_level >= 2) myconsole.log("          digit = "+digit);
           const house2cellsContainingDigit = [];
           for (let ihouse = 0; ihouse < house2cells.length; ++ihouse) {
             house2cellsContainingDigit.push(new Set());
             for (const cell of house2cells[ihouse]) {
               if (oldState[cell].includes(digit)) {
                 Last(house2cellsContainingDigit).add(cell);
               }
             }
           }
           if (verbose_level >= 2) myconsole.log("          house2cellsContainingDigit = "+Stringify(house2cellsContainingDigit));
           for (let ihouse0 = 0; ihouse0 < house2cellsContainingDigit.length; ++ihouse0) {
             if (verbose_level >= 2) myconsole.log("              ihouse0 = "+ihouse0);
             const cells0 = house2cellsContainingDigit[ihouse0];
             CHECK_GE(cells0.size, 1);
             if (cells0.size == 1) continue;  // this is already covered under lone single or something
             for (let ihouse1 = 0; ihouse1 < house2cellsContainingDigit.length; ++ihouse1) {
               if (ihouse0 == ihouse1) continue;
               const cells1 = house2cellsContainingDigit[ihouse1];
               if (cells1.size === 0) {
                 if (verbose_level >= 1) myconsole.log("        out doOmissions(n="+n+", state), returning oldState because illegal");
                 return oldState;
                }

               // Are all occurrances of digit in house0 also in house1?
               if (IsSubsetOf(cells0, cells1)) {
                 if (verbose_level >= 2) myconsole.log("              Hey! every occurrance of digit "+digit+" in house "+ihouse0+" is also in "+ihouse1);
                 if (verbose_level >= 2) myconsole.log("                  cells0 = "+Array.from(cells0));
                 if (verbose_level >= 2) myconsole.log("                  cells1 = "+Array.from(cells1));

                 const actually_did_stuff = [];
                 // Remove all other occurrances of digit in house1.
                 for (const cell of house2cells[ihouse1]) {
                   if (oldState[cell].includes(digit) &&
                       !cell2houses[cell].includes(ihouse0)) {
                     if (verbose_level >= 2) myconsole.log("                      so can remove the "+digit+" at position "+Stringify(cell));
                     if (oldState[cell].includes(digit)) {
                       actually_did_stuff.push(cell);
                     }
                     removeIf(newState[cell], x => x===digit);
                   }
                 }
                 if (actually_did_stuff.length > 0) {
                   if (verbose_level >= 2) myconsole.log("                  actually_did_stuff = "+Stringify(actually_did_stuff));
                   if (verbose_level >= 1) myconsole.log("                  "+cellset2terse(n,cells0)+" => "+cellset2terse(n,actually_did_stuff)+"<>"+digit);
                 }
               }
             }
           }
         }

         if (verbose_level >= 1) myconsole.log("        out doOmissions(n="+n+", state)");
         return newState;
       };  // doOmissions

       const Cell2Description = cell => 'r'+cell2row[cell]+'c'+cell2col[cell]+'b'+cell2block[cell];

       const doXwingsNEW = (n, oldState) => {
         const verbose_level = 1;  // 2 seems to be useful, it can be pretty cryptic otherwise. unfortunately it contributes to console lag :-(  and, holy moly, is this THE thing that causes the console lag??? wtf? I guess not, but it certainly is a major contributor.
         if (verbose_level >= 1) myconsole.log("        in doXwingsNEW(n="+n+", state)");
         const newState = deepCopy(oldState);
         // And x-wing is when, for a given digit,
         // there is a pair of houses (say, rows) such that
         // all the occurrances of this digit
         // on these two houses
         // span only two houses of some different type (say, cols).
         for (let digit = 1; digit <= n*n; ++digit) {
           if (verbose_level >= 2) myconsole.log("          digit = "+digit);
           const house2cellsContainingDigit = [];
           for (let ihouse = 0; ihouse < house2cells.length; ++ihouse) {
             house2cellsContainingDigit.push([]);
             for (const cell of house2cells[ihouse]) {
               if (oldState[cell].includes(digit)) {
                 Last(house2cellsContainingDigit).push(cell);
               }
             }
           }
           // Which houses have exactly two possible positions for this digit?
           const housesContainingDigitTwice = [];
           for (let ihouse = 0; ihouse < house2cellsContainingDigit.length; ++ihouse) {
             if (house2cellsContainingDigit[ihouse].length === 2) {
               housesContainingDigitTwice.push(ihouse);
             }
           }
           if (verbose_level >= 3) myconsole.log("              housesContainingDigitTwice = "+Stringify(Sub(houseNames, housesContainingDigitTwice)));
           const housesOfTypeContainingDigitTwice = [[],[],[]];
           for (const house of housesContainingDigitTwice) {
             const houseType = Div(house, n*n);
             housesOfTypeContainingDigitTwice[houseType].push(house);
           }
           if (verbose_level >= 2) myconsole.log("              housesOfTypeContainingDigitTwice = "+Stringify(Sub(houseNames, housesOfTypeContainingDigitTwice)));

           for (let housetype0 = 0; housetype0 < 3; ++housetype0) {
             for (let housetype1 = 0; housetype1 < 3; ++housetype1) {
               if (housetype1 == housetype0) continue;
               if (verbose_level >= 2) myconsole.log("              housetype0="+housetype0+" housetype1="+housetype1);
               for (const ihouse00 of housesOfTypeContainingDigitTwice[housetype0]) {
                 if (verbose_level >= 2) myconsole.log("                  ihouse00 = "+ihouse00);
                 {
                   const ihouse00_spannedHousesOfType1 = new Set();
                   for (const cell of house2cellsContainingDigit[ihouse00]) {
                       ihouse00_spannedHousesOfType1.add(housetype1*(n*n) +
                                                         (housetype1===0 ? cell2row[cell] :
                                                          housetype1===1 ? cell2col[cell] : cell2block[cell]));
                   }
                   if (verbose_level >= 2) myconsole.log("                      ihouse00_spannedHousesOfType1.size = "+ihouse00_spannedHousesOfType1.size);
                   if (ihouse00_spannedHousesOfType1.size == 1) {
                     // Both cells are in the same house of type 1.
                     // This is caught under a simpler analysis ("omission").
                     // It can happen only if one of the two types is block.
                     CHECK(housetype0 == 2 || housetype1 == 2);
                     //CHECK(false);  // coverage: yes, hit
                     continue;
                   }
                   CHECK_EQ(ihouse00_spannedHousesOfType1.size, 2);
                 }

                 for (const ihouse01 of housesOfTypeContainingDigitTwice[housetype0]) {
                   if (ihouse01 <= ihouse00) continue;  // do them only in canonical order ihouse00<ihouse01
                   if (verbose_level >= 2) myconsole.log("                      ihouse01 = "+ihouse01);
                   {
                     const ihouse01_spannedHousesOfType1 = new Set();
                     for (const cell of house2cellsContainingDigit[ihouse01]) {
                         ihouse01_spannedHousesOfType1.add(housetype1*(n*n) +
                                                           (housetype1===0 ? cell2row[cell] :
                                                            housetype1===1 ? cell2col[cell] : cell2block[cell]));
                     }
                     if (verbose_level >= 2) myconsole.log("                      ihouse01_spannedHousesOfType1.size = "+ihouse01_spannedHousesOfType1.size);
                     if (ihouse01_spannedHousesOfType1.size == 1) {
                       // Both cells are in the same house of type 1.
                       // This is caught under a simpler analysis ("omission").
                       // It can happen only if one of the two types is block.
                       CHECK(housetype0 == 2 || housetype1 == 2);
                       //CHECK(false);  // coverage: yes, hit
                       continue;
                     }
                     CHECK_EQ(ihouse01_spannedHousesOfType1.size, 2);
                   }



                   if (verbose_level >= 3) myconsole.log("                  "+[ihouse00,ihouse01].map(ihouse=>houseNames[ihouse]));
                   const the4cells = new Set([...house2cellsContainingDigit[ihouse00],
                                              ...house2cellsContainingDigit[ihouse01]]);
                   CHECK_EQ(the4cells.size, 4);  // two distinct on one row and two distinct on another
                   const spannedHousesOfType1 = new Set();
                   for (const cell of the4cells) {
                     spannedHousesOfType1.add(housetype1*(n*n) +
                                              (housetype1===0 ? cell2row[cell] :
                                               housetype1===1 ? cell2col[cell] : cell2block[cell]));
                   }
                   // CBB: this can fail if theres no solution;
                   // should do something more graceful in that case
                   CHECK_GE(spannedHousesOfType1.size, 2);
                   if (EQ(spannedHousesOfType1.size, 2)) {
                     if (verbose_level >= 2) myconsole.log("              FOUND AN XWING ON "+[ihouse00,ihouse01].map(ihouse=>houseNames[ihouse])+" AFFECTING "+[...spannedHousesOfType1].map(ihouse=>houseNames[ihouse])+"!");
                     if (verbose_level >= 2) myconsole.log("                the4cells="+Stringify(the4cells)+" = "+Stringify([...the4cells].map(cell=>Cell2Description(cell))));
                     // Remove digit from the two houses of type 1,
                     // except for the 4 cells in question.
                     for (const ihouse1 of spannedHousesOfType1) {
                       for (const cell of house2cells[ihouse1]) {
                         if (!the4cells.has(cell)) {
                           removeIf(newState[cell], x => x===digit);
                         }
                       }
                     }
                   }
                 }
               }
             }
           }
         }

         if (verbose_level >= 1) myconsole.log("        out doXwingsNEW(n="+n+", state)");
         return newState;
       };  // doXwingsNEW

       // Keeping this around in case I need to do another overhaul and test it.
       const doXwings = (n, oldState) => {
         const verbose_level = 1;
         if (verbose_level >= 1) myconsole.log("        in doXwings(n="+n+", state)");
         //const answerOLD = doXwingsOLD(n, oldState);
         const answerNEW = doXwingsNEW(n, oldState);
         //CHECK(deepEquals(answerOLD, answerNEW));
         if (verbose_level >= 1) myconsole.log("        out doXwings(n="+n+", state)");
         return answerNEW;
       };  // doXwings

       const propagateSinglesButton = document.getElementsByClassName("propagatesingles")[0];
       const hiddenSinglesButton = document.getElementsByClassName("hiddensingles")[0];
       const nakedPairsButton = document.getElementsByClassName("nakedpairs")[0];
       const hiddenPairsButton = document.getElementsByClassName("hiddenpairs")[0];
       const nakedTriplesButton = document.getElementsByClassName("nakedtriples")[0];
       const hiddenTriplesButton = document.getElementsByClassName("hiddentriples")[0];
       const nakedQuadsButton = document.getElementsByClassName("nakedquads")[0];
       const hiddenQuadsButton = document.getElementsByClassName("hiddenquads")[0];
       const omissionButton = document.getElementsByClassName("omission")[0];
       const xwingButton = document.getElementsByClassName("xwing")[0];
       const fish1Button = document.getElementsByClassName("fish1")[0];
       const fish2Button = document.getElementsByClassName("fish2")[0];
       const fish3Button = document.getElementsByClassName("fish3")[0];
       const fish4Button = document.getElementsByClassName("fish4")[0];
       const undoButton = document.getElementsByClassName("undo")[0];
       const redoButton = document.getElementsByClassName("redo")[0];
       const propagateSinglesCountSpan = document.getElementsByClassName("propagatesinglescount")[0];
       const doHiddenSinglesCountSpan = document.getElementsByClassName("dohiddensinglescount")[0];
       const doNakedPairsCountSpan = document.getElementsByClassName("donakedpairscount")[0];
       const doHiddenPairsCountSpan = document.getElementsByClassName("dohiddenpairscount")[0];
       const doNakedTriplesCountSpan = document.getElementsByClassName("donakedtriplescount")[0];
       const doHiddenTriplesCountSpan = document.getElementsByClassName("dohiddentriplescount")[0];
       const doNakedQuadsCountSpan = document.getElementsByClassName("donakedquadscount")[0];
       const doHiddenQuadsCountSpan = document.getElementsByClassName("dohiddenquadscount")[0];
       const doOmissionsCountSpan = document.getElementsByClassName("doomissionscount")[0];
       const doXwingsCountSpan = document.getElementsByClassName("doxwingscount")[0];
       const doFish1sCountSpan = document.getElementsByClassName("dofish1scount")[0];
       const doFish2sCountSpan = document.getElementsByClassName("dofish2scount")[0];
       const doFish3sCountSpan = document.getElementsByClassName("dofish3scount")[0];
       const doFish4sCountSpan = document.getElementsByClassName("dofish4scount")[0];
       const undoStackSizeSpan = document.getElementsByClassName("undostacksize")[0];
       const redoStackSizeSpan = document.getElementsByClassName("redostacksize")[0];

       const howManyTimesStateWillChange= (state,state2changedState) => {
         let answer = 0;
         while (true) {
           const newState = state2changedState(state);
           if (deepEquals(newState, state)) {
             break;
           }
           ++answer;
           state = newState;
         }
         return answer;
       };  // howManyTimesStateWillChange

       // This must be separate from updateUiFromStatePair: we do *not* want
       // to do it on mousedown, since that will prevent recognizing mouseup!
       const _updateUndoRedoButtons = () => {
         const verbose_level = 1;
         if (verbose_level >= 1) myconsole.log("    in _updateUndoRedoButtons");

         if (false) {
           if (verbose_level >= 1) myconsole.log("    out _updateUndoRedoButtons (NOT DOING ANYTHING)");
           return;
         }

         undoButton.disabled = (undoStack.length === 0);
         redoButton.disabled = (redoStack.length === 0);
         undoStackSizeSpan.innerHTML = ''+undoStack.length;
         redoStackSizeSpan.innerHTML = ''+redoStack.length;
         const nPropagates = howManyTimesStateWillChange(state, scratchState=>doPropagateSingles(n,scratchState));
         const nDoHiddenSingles = howManyTimesStateWillChange(state, scratchState=>doHiddenSingles(n,scratchState));
         const nDoNakedPairs = howManyTimesStateWillChange(state, scratchState=>doNakedTuples(2,n,scratchState));
         const nDoHiddenPairs = howManyTimesStateWillChange(state, scratchState=>doHiddenTuples(2,n,scratchState));
         const nDoNakedTriples = howManyTimesStateWillChange(state, scratchState=>doNakedTuples(3,n,scratchState));
         const nDoHiddenTriples = howManyTimesStateWillChange(state, scratchState=>doHiddenTuples(3,n,scratchState));
         const nDoNakedQuads = howManyTimesStateWillChange(state, scratchState=>doNakedTuples(4,n,scratchState));
         const nDoHiddenQuads = howManyTimesStateWillChange(state, scratchState=>doHiddenTuples(4,n,scratchState));
         const nDoOmissions = howManyTimesStateWillChange(state, scratchState=>doOmissions(n,scratchState));
         const nDoXwings = howManyTimesStateWillChange(state, scratchState=>doXwings(n,scratchState));
         const nDoFish1s = howManyTimesStateWillChange(state, scratchState=>doFishes(1,1,n,scratchState));
         const nDoFish2s = howManyTimesStateWillChange(state, scratchState=>doFishes(2,2,n,scratchState));
         const nDoFish3s = howManyTimesStateWillChange(state, scratchState=>doFishes(3,3,n,scratchState));
         const nDoFish4s = howManyTimesStateWillChange(state, scratchState=>doFishes(4,4,n,scratchState));

         propagateSinglesButton.disabled = nPropagates===0;
         hiddenSinglesButton.disabled = nDoHiddenSingles===0;
         nakedPairsButton.disabled = nDoNakedPairs===0;
         hiddenPairsButton.disabled = nDoHiddenPairs===0;
         nakedTriplesButton.disabled = nDoNakedTriples===0;
         hiddenTriplesButton.disabled = nDoHiddenTriples===0;
         nakedQuadsButton.disabled = nDoNakedQuads===0;
         hiddenQuadsButton.disabled = nDoHiddenQuads===0;
         omissionButton.disabled = nDoOmissions===0;
         xwingButton.disabled = nDoXwings===0;
         fish1Button.disabled = nDoFish1s===0;
         fish2Button.disabled = nDoFish2s===0;
         fish3Button.disabled = nDoFish3s===0;
         fish4Button.disabled = nDoFish4s===0;

         propagateSinglesCountSpan.innerHTML = ''+nPropagates;
         doHiddenSinglesCountSpan.innerHTML = ''+nDoHiddenSingles;
         doNakedPairsCountSpan.innerHTML = ''+nDoNakedPairs;
         doHiddenPairsCountSpan.innerHTML = ''+nDoHiddenPairs;
         doNakedTriplesCountSpan.innerHTML = ''+nDoNakedTriples;
         doHiddenTriplesCountSpan.innerHTML = ''+nDoHiddenTriples;
         doNakedQuadsCountSpan.innerHTML = ''+nDoNakedQuads;
         doHiddenQuadsCountSpan.innerHTML = ''+nDoHiddenQuads;
         doOmissionsCountSpan.innerHTML = ''+nDoOmissions;
         doXwingsCountSpan.innerHTML = ''+nDoXwings;
         doFish1sCountSpan.innerHTML = ''+nDoFish1s;
         doFish2sCountSpan.innerHTML = ''+nDoFish2s;
         doFish3sCountSpan.innerHTML = ''+nDoFish3s;
         doFish4sCountSpan.innerHTML = ''+nDoFish4s;

         if (verbose_level >= 1) myconsole.log("    out _updateUndoRedoButtons");
       };
       const updateUndoRedoButtons = () => {
         const verbose_level = 1;
         if (verbose_level >= 1) myconsole.log("in updateUndoRedoButtons");
         thinking.innerHTML = "thinking";
         const f = ()=>{
           _updateUndoRedoButtons();
           thinking.innerHTML = "done thinking";
         };
         if (false) {
           // try to get significant work out of the event handler.
           // it doesn't help :-(  ) Now I get "[Violation] 'setTimeout' handler took 64ms"
           // and console still slows to a crawl
           setTimeout(f);
         } else {
           f();
         }
         if (verbose_level >= 1) myconsole.log("out updateUndoRedoButtons");
      }

       const highlightDigit = (state,digit) => {
         CHECK(Array.isArray(state));
         CHECK(typeof(digit) === 'number');
         for (let icell = 0; icell < n*n*n*n; ++icell) {
           if (state[icell].length === 1 && EQ(state[icell][0], digit)) {
             // note 'green' is #008000
             cells[icell].style.background = '#00c000';
           } else if (state[icell].length === 1) {
             cells[icell].style.background = '#ffa0a0';  // slightly darker pink
           } else if (state[icell].includes(digit)) {
             cells[icell].style.background = '#c0ffc0';  // light green
           } else {
             cells[icell].style.background = '#ffc0c0';  // pink
           }
         }
       };  // highlightDigit
       const unhighlightDigit = (state) => {
         CHECK(Array.isArray(state));
         for (let icell = 0; icell < n*n*n*n; ++icell) {
           // default to style sheet
           cells[icell].style.background = null;
         }
       };  // unhighlightDigit


       // Show common stuff in black, appearing stuff in green, disappearing stuff in red
       const updateUiFromStatePair = (state0,state1) => {
         CHECK(Array.isArray(state0));
         CHECK(Array.isArray(state1));
         for (let i = 0; i < n*n; ++i) {
           for (let j = 0; j < n*n; ++j) {
             if (state0[i*(n*n)+j].length === 1 &&
                 state1[i*(n*n)+j].length === 1 &&
                 state0[i*(n*n)+j][0] == state1[i*(n*n)+j][0]) {
               const intvalue = state0[i*(n*n)+j][0];
               const charvalue = intvalue2name(intvalue);
               cells[i*n*n+j].innerHTML = charvalue;
             } else {
               let cell_inner_html = '';
               cell_inner_html += '<table>'

               for (let subi = 0; subi < n; ++subi) {
                 cell_inner_html += '<tr>'
                 for (let subj = 0; subj < n; ++subj) {
                   cell_inner_html += '<td class="pencil">'
                   const intvalue = subi*n+subj+1;
                   const includes0 = state0[i*(n*n)+j].includes(intvalue);
                   const includes1 = state1[i*(n*n)+j].includes(intvalue);
                   if (includes0 || includes1) {
                     const color = !includes0 ? '#00c000' : !includes1 ? 'red' : 'black';
                     const weight = !includes0 || !includes1 ? 'bold' : 'normal';
                     cell_inner_html += '<span style="font-weight:'+weight+'; color:'+color+';">';
                     // TODO: make it so size doesn't jump, and do this <big> thing!
                     //if (!includes0 || !includes1) { cell_inner_html += '<big>'; }
                     cell_inner_html += '' + intvalue2name(intvalue);
                     //if (!includes0 || !includes1) { cell_inner_html += '</big>'; }
                     cell_inner_html += '</span>';
                   }
                 }
               }
               cell_inner_html += '</table>'
               cells[i*n*n+j].innerHTML = cell_inner_html;
             }
           }
         }
         if (digitToHighlight !== null) {
           highlightDigit(state1,digitToHighlight);
         } else {
           unhighlightDigit(state1);
         }
       };  // updateUiFromStatePair

       // CBB: really need to distinguish between penned and pencilled single!
       state = doPropagateSingles(n, state);
       updateUiFromStatePair(state,state);
       updateUndoRedoButtons();

       window.propagateSinglesButtonMouseOver = () => {
         myconsole.log("    in propagateSinglesButtonMouseOver");
         myconsole.doWhileBuffered(()=>{
           let scratchState = doPropagateSingles(n, state);
           updateUiFromStatePair(state,scratchState);
           myconsole.log("    out propagateSinglesButtonMouseOver");
         });
       };
       window.propagateSinglesButtonMouseDown = () => {
         myconsole.log("    in propagateSinglesButtonMouseDown");
         myconsole.doWhileBuffered(()=>{
           myconsole.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           redoStack.length = 0;  // clear
           undoStack.push(state);
           state = doPropagateSingles(n, state);
           updateUiFromStatePair(Last(undoStack),state);
           myconsole.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           myconsole.log("    out propagateSinglesButtonMouseDown");
         });
       };

       window.hiddenSinglesButtonMouseOver = () => {
         myconsole.log("    in propagateSinglesButtonMouseOver");
         myconsole.doWhileBuffered(()=>{
           const scratchState = doHiddenSingles(n, state);
           updateUiFromStatePair(state,scratchState);
           myconsole.log("    out propagateSinglesButtonMouseOver");
         });
       };
       window.hiddenSinglesButtonMouseDown = () => {
         myconsole.log("    in hiddenSinglesButtonMouseDown");
         myconsole.doWhileBuffered(()=>{
           myconsole.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           redoStack.length = 0;  // clear
           undoStack.push(state);
           state = doHiddenSingles(n, state);
           updateUiFromStatePair(Last(undoStack),state);
           myconsole.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           myconsole.log("    out hiddenSinglesButtonMouseDown");
         });
       };

       window.nakedPairsButtonMouseOver = () => {
         myconsole.log("    in nakedPairsButtonMouseOver");
         myconsole.doWhileBuffered(()=>{
           const scratchState = doNakedTuples(2, n, state);
           updateUiFromStatePair(state,scratchState);
           myconsole.log("    out nakedPairsButtonMouseOver");
         });
       };
       window.nakedPairsButtonMouseDown = () => {
         myconsole.log("    in nakedPairsButtonMouseDown");
         myconsole.doWhileBuffered(()=>{
           myconsole.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           redoStack.length = 0;  // clear
           undoStack.push(state);
           state = doNakedTuples(2, n, state);
           updateUiFromStatePair(Last(undoStack),state);
           myconsole.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           myconsole.log("    out nakedPairsButtonMouseDown");
         });
       };

       window.nakedTriplesButtonMouseOver = () => {
         myconsole.log("    in nakedTriplesButtonMouseOver");
         myconsole.doWhileBuffered(()=>{
           const scratchState = doNakedTuples(3, n, state);
           updateUiFromStatePair(state,scratchState);
           myconsole.log("    out nakedTriplesButtonMouseOver");
         });
       };
       window.nakedTriplesButtonMouseDown = () => {
         myconsole.log("    in nakedTriplesButtonMouseDown");
         myconsole.doWhileBuffered(()=>{
           myconsole.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           redoStack.length = 0;  // clear
           undoStack.push(state);
           state = doNakedTuples(3, n, state);
           updateUiFromStatePair(Last(undoStack),state);
           myconsole.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           myconsole.log("    out nakedTriplesButtonMouseDown");
         });
       };

       window.hiddenTriplesButtonMouseOver = () => {
         myconsole.log("    in hiddenTriplesButtonMouseOver");
         myconsole.doWhileBuffered(()=>{
           const scratchState = doHiddenTuples(3, n, state);
           updateUiFromStatePair(state,scratchState);
           myconsole.log("    out hiddenTriplesButtonMouseOver");
         });
       };
       window.hiddenTriplesButtonMouseDown = () => {
         myconsole.log("    in hiddenTriplesButtonMouseDown");
         myconsole.doWhileBuffered(()=>{
           myconsole.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           redoStack.length = 0;  // clear
           undoStack.push(state);
           state = doHiddenTuples(3, n, state);
           updateUiFromStatePair(Last(undoStack),state);
           myconsole.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           myconsole.log("    out hiddenTriplesButtonMouseDown");
         });
       };

       window.nakedQuadsButtonMouseOver = () => {
         myconsole.log("    in nakedQuadsButtonMouseOver");
         myconsole.doWhileBuffered(()=>{
           const scratchState = doNakedTuples(4, n, state);
           updateUiFromStatePair(state,scratchState);
           myconsole.log("    out nakedQuadsButtonMouseOver");
         });
       };
       window.nakedQuadsButtonMouseDown = () => {
         myconsole.log("    in nakedQuadsButtonMouseDown");
         myconsole.doWhileBuffered(()=>{
           myconsole.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           redoStack.length = 0;  // clear
           undoStack.push(state);
           state = doNakedTuples(4, n, state);
           updateUiFromStatePair(Last(undoStack),state);
           myconsole.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           myconsole.log("    out nakedQuadsButtonMouseDown");
         });
       };

       window.hiddenQuadsButtonMouseOver = () => {
         myconsole.log("    in hiddenQuadsButtonMouseOver");
         myconsole.doWhileBuffered(()=>{
           const scratchState = doHiddenTuples(4, n, state);
           updateUiFromStatePair(state,scratchState);
           myconsole.log("    out hiddenQuadsButtonMouseOver");
         });
       };
       window.hiddenQuadsButtonMouseDown = () => {
         myconsole.log("    in hiddenQuadsButtonMouseDown");
         myconsole.doWhileBuffered(()=>{
           myconsole.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           redoStack.length = 0;  // clear
           undoStack.push(state);
           state = doHiddenTuples(4, n, state);
           updateUiFromStatePair(Last(undoStack),state);
           myconsole.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           myconsole.log("    out hiddenQuadsButtonMouseDown");
         });
       };

       window.hiddenPairsButtonMouseOver = () => {
         myconsole.log("    in hiddenPairsButtonMouseOver");
         myconsole.doWhileBuffered(()=>{
           const scratchState = doHiddenTuples(2, n, state);
           updateUiFromStatePair(state,scratchState);
           myconsole.log("    out hiddenPairsButtonMouseOver");
         });
       };
       window.hiddenPairsButtonMouseDown = () => {
         myconsole.log("    in hiddenPairsButtonMouseDown");
         myconsole.doWhileBuffered(()=>{
           myconsole.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           redoStack.length = 0;  // clear
           undoStack.push(state);
           state = doHiddenTuples(2, n, state);
           updateUiFromStatePair(Last(undoStack),state);
           myconsole.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           myconsole.log("    out hiddenPairsButtonMouseDown");
         });
       };

       window.omissionButtonMouseOver = () => {
         myconsole.log("    in omissionButtonMouseOver");
         myconsole.doWhileBuffered(()=>{
           const scratchState = doOmissions(n, state);
           updateUiFromStatePair(state,scratchState);
           myconsole.log("    out omissionButtonMouseOver");
         });
       };
       window.omissionButtonMouseDown = () => {
         myconsole.log("    in omissionButtonMouseDown");
         myconsole.doWhileBuffered(()=>{
           myconsole.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           redoStack.length = 0;  // clear
           undoStack.push(state);
           state = doOmissions(n, state);
           updateUiFromStatePair(Last(undoStack),state);
           myconsole.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           myconsole.log("    out omissionButtonMouseDown");
         });
       };

       window.xwingButtonMouseOver = () => {
         myconsole.log("    in xwingButtonMouseOver");
         myconsole.doWhileBuffered(()=>{
           const scratchState = doXwings(n, state);
           updateUiFromStatePair(state,scratchState);
           myconsole.log("    out xwingButtonMouseOver");
         });
       };
       window.xwingButtonMouseDown = () => {
         myconsole.log("    in xwingButtonMouseDown");
         myconsole.doWhileBuffered(()=>{
           myconsole.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           redoStack.length = 0;  // clear
           undoStack.push(state);
           state = doXwings(n, state);
           updateUiFromStatePair(Last(undoStack),state);
           myconsole.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           myconsole.log("    out xwingButtonMouseDown");
         });
       };

       window.fishButtonMouseOver = (fish_size) => {
         myconsole.log("    in fishButtonMouseOver");
         myconsole.doWhileBuffered(()=>{
           const scratchState = doFishes(fish_size,fish_size, n, state);
           updateUiFromStatePair(state,scratchState);
           myconsole.log("    out fishButtonMouseOver");
         });
       };
       window.fishButtonMouseDown = (fish_size) => {
         myconsole.log("    in fishButtonMouseDown");
         myconsole.doWhileBuffered(()=>{
           myconsole.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           redoStack.length = 0;  // clear
           undoStack.push(state);
           state = doFishes(fish_size,fish_size, n, state);
           updateUiFromStatePair(Last(undoStack),state);
           myconsole.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           myconsole.log("    out fishButtonMouseDown");
         });
       };

       window.undoButtonMouseDown = () => {
         myconsole.log("    in undoButtonMouseDown");
         myconsole.doWhileBuffered(()=>{
           myconsole.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           if (undoStack.length >= 1) {
             redoStack.push(state);
             state = undoStack.pop();
             // It seems to be less confusing if we show
             // undos in the same color as the do's/redo's,
             // even though they are doing the opposite thing.
             updateUiFromStatePair(state, Last(redoStack));
           } else {
             // This shouldn't ever happen because the button should be disabled
             // when there's nothing to undo.
             myconsole.log("      nothing to undo!");
           }
           myconsole.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           myconsole.log("    out undoButtonMouseDown");
         });
       };
       window.redoButtonMouseDown = () => {
         myconsole.log("    in redoButtonMouseDown");
         myconsole.doWhileBuffered(()=>{
           myconsole.log("      before: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           if (redoStack.length >= 1) {
             undoStack.push(state);
             state = redoStack.pop();
             updateUiFromStatePair(Last(undoStack), state);
           } else {
             // This shouldn't ever happen because the button should be disabled
             // when there's nothing to redo.
             myconsole.log("      nothing to redo!");
           }
           myconsole.log("      after: undoStack.length = "+undoStack.length+" redoStack.length = "+redoStack.length);
           myconsole.log("    out redoButtonMouseDown");
         });
       };

       window.anyButtonMouseOut = () => {
         myconsole.log("    in anyButtonMouseOut");
         myconsole.doWhileBuffered(()=>{
           updateUiFromStatePair(state,state);
           myconsole.log("    out anyButtonMouseOut");
         });
       };
       window.anyButtonMouseUp = () => {
         myconsole.log("    in anyButtonMouseUp");
         myconsole.doWhileBuffered(()=>{
           updateUiFromStatePair(state,state);
           updateUndoRedoButtons();
           myconsole.log("    out anyButtonMouseUp");
         });
       };


       window.mouseOverCell = (event,icell) => {
         const verbose_level = 0;
         if (verbose_level >= 1) myconsole.log("    in mouseOverCell");
         myconsole.doWhileBuffered(()=>{
           if (verbose_level >= 1) myconsole.log("      event = ",event);
           if (verbose_level >= 1) myconsole.log("      icell = ",icell);
           let newDigitToHighlight = null;
           if (state[icell].length == 1) {
             newDigitToHighlight = state[icell][0];
           }
           if (newDigitToHighlight != digitToHighlight) {
             digitToHighlight = newDigitToHighlight;
             updateUiFromStatePair(state,state);
           }
           if (verbose_level >= 1) myconsole.log("    out mouseOverCell");
         });
       };  // mouseOverCell
       window.mouseOutCell = (event,icell) => {
         const verbose_level = 0;
         if (verbose_level >= 1) myconsole.log("    in mouseOutCell");
         myconsole.doWhileBuffered(()=>{
           if (verbose_level >= 1) myconsole.log("      event = ",event);
           if (verbose_level >= 1) myconsole.log("      icell = ",icell);
           let newDigitToHighlight = null;
           if (newDigitToHighlight != digitToHighlight) {
             digitToHighlight = newDigitToHighlight;
             updateUiFromStatePair(state,state);
           }
           if (verbose_level >= 1) myconsole.log("    out mouseOutCell");
         });
       };  // mouseOutCell

       window.processPastedInput = pastedInput => {
         myconsole.log("        in processPastedInput");
         myconsole.log("          pastedInput = ",pastedInput);
         const outerHTML = pastedInput;

         let prefill_string;
         if (outerHTML.indexOf('grilleJeu') != -1) {
           prefill_string = ExtractPrefillStringFrom1SudokoOuterHTML(outerHTML)
         } else if (outerHTML.indexOf('div class="grid"') != -1 &&
                    outerHTML.indexOf('div class="cells"') != -1 &&
                    outerHTML.indexOf('id="cell-givens"') != -1) {
           prefill_string = ExtractPrefillStringFromCrackingTheCrypticOuterHTML(outerHTML);
         } else if (outerHTML.indexOf('div role="grid" class="su-board"') != -1 ||
                    outerHTML.indexOf('class="su-cell') != -1) {
           // Reason for checking for su-cell
           // is in case someone grepped for that in the output
           // before pasting: if they paste the whole grid thing,
           // it's too huge :-( )
           //   vi 0
           //     s/</<^M/g
           //   grep su-cell 0 | grep -v su-cell__ > 1
           prefill_string = ExtractPrefillStringFromNYTimesOuterHTML(outerHTML);
         } else if (outerHTML.indexOf('div class="crossword"') != -1 ||
                    outerHTML.indexOf('class="letter-in-box') != -1) {
           // Same reasoning as for NYTimes, for checking letter-in-box
           //   vi 0
           //     s/</<^M/g
           //   grep span 0 > 1
           //
           prefill_string = ExtractPrefillStringFromLATimesOuterHTML(outerHTML);
         } else if (true) {
           // Format I see used in http://forum.enjoysudoku.com/a-pure-swordfish-collection-t5775.html:
           /*
               2 . . | . 9 . | . . .
               . 6 . | . . 3 | 1 . .
               . . 1 | 2 . . | . 7 .
              -------+-------+------
               . . 7 | . . . | . 2 .
               3 . . | . . . | . . 8
               . 8 . | . . . | 4 . .
              -------+-------+------
               . 4 . | . . 8 | 6 . .
               . . 2 | 7 . . | . 1 .
               . . . | . 5 . | . . 4
           // Everything except dots and digits and letters are ignored, so the following also works:
           /*
            2...9.....6...31....12...7...7....2.3.......8.8....4...4...86....27...1.....5...4
           */

           prefill_string = outerHTML.replace(/[^.0-9a-zA-Z]/g, '').replace(/\./g, '0');
         } else {
           // TODO: more graceful rejection than this!
           // Actually validate and color green/red accordingly!
           console.warn("WARNING: unrecognized outerHTML");
           prefill_string = '';
         }

         [n,prefill] = PrefillString2Prefill(prefill_string);
         myconsole.log("      prefill = ",prefill);
         [n,state,cells,undoStack,redoStack,
          cell2row,cell2col,cell2block,cell2houses,house2cells] = PopulateIt(prefill);
         state = doPropagateSingles(n, state);
         updateUiFromStatePair(state,state);
         updateUndoRedoButtons();
         myconsole.log("        out processPastedInput");
       };  // processPastedInput

       window.resetButtonClicked = () => {
         myconsole.log("    in resetButtonClicked");
         myconsole.doWhileBuffered(()=>{

           //const prefill_string = '1300020000300004';

           const prefill_input = document.getElementById("prefill");
           myconsole.log("      prefill_input = ",prefill_input);
           CHECK(prefill_input != null);
           myconsole.log("      prefill_input.value = ",prefill_input.value);

           processPastedInput(prefill_input.value);

           myconsole.log("    out resetButtonClicked");
         });
       };  // resetButtonClicked

       window.inputKeyDown = (event) => {
         myconsole.log("    in inputKeyDown");
         myconsole.doWhileBuffered(()=>{
           myconsole.log("      event = ",event);
           // XXX TODO: which of these do I want? evidently both work
           //const element = event.srcElement;
           const element = event.target;
           if (EQ(event.key, "Enter")) {
             //processPastedInput(document.getElementById("prefill").value);
             processPastedInput(element.value);
           }
           myconsole.log("    out inputKeyDown");
         });
       };  // inputKeyDown
       window.inputPasted = event => {
         myconsole.log("    in inputPasted");
         myconsole.doWhileBuffered(()=>{
           myconsole.log("      event = ",event);
           // XXX TODO: which of these do I want? evidently both work
           //const element = event.srcElement;
           const element = event.target;
           myconsole.log("      event.clipboardData = ",event.clipboardData);
           myconsole.log("      event.clipboardData.getData() = ",event.clipboardData.getData('text/plain'));
           const theData = event.clipboardData.getData('text/plain');
           myconsole.log("      theData.length = ",theData.length);
           if (theData.length >= 1000) {
             myconsole.log('      preventing default to avoid choking!');
             event.preventDefault();
             element.value = "[[[paste of size "+theData.length+" accepted but CENSORED to avoid choking]]]";
             processPastedInput(theData);
           }
           myconsole.log("    out inputPasted");
         });
       };

       //myconsole.log("  file_contents = ",file_contents);
     } catch (error) {
       console.error("ARGH, caught error: ",error);
       // CBB: oh this isn't good... output leading up to it gets lost now as we throw away the page.
       CHECK(false);
     }
   });

   myconsole.log("out script");
   console.log("out script");
 </script>
</html>
